From 3c936d00a87bff96df4e0fbef8dd5a4782db8b48 Mon Sep 17 00:00:00 2001
From: itrytoohard <ayetrytoohard@gmail.com>
Date: Thu, 17 Jul 2025 03:33:52 -0700
Subject: [PATCH] improve AI suggestions

---
 pickleglass_web/app/research/page.tsx         |  559 +++++++
 pickleglass_web/package-lock.json             |   10 +
 pickleglass_web/package.json                  |    1 +
 src/bridge/featureBridge.js                   |   63 +
 src/features/common/config/schema.js          |   71 +
 src/features/common/services/sqliteClient.js  |    1 +
 src/features/listen/listenService.js          |    9 +
 .../repositories/questionResponse/index.js    |    9 +
 .../questionResponse/sqlite.repository.js     |  118 ++
 .../repositories/researchQuestion/index.js    |   13 +
 .../researchQuestion/sqlite.repository.js     |  122 ++
 .../repositories/researchSession/index.js     |    8 +
 .../researchSession/sqlite.repository.js      |   95 ++
 .../repositories/researchStudy/index.js       |   58 +
 .../researchStudy/sqlite.repository.js        |  127 ++
 src/features/research/researchService.js      | 1403 +++++++++++++++++
 src/preload.js                                |   37 +
 src/ui/app/MainHeader.js                      |   28 +
 src/ui/app/PickleGlassApp.js                  |    9 +-
 src/ui/listen/audioCore/renderer.js           |    7 +-
 src/ui/research/ResearchView.js               | 1282 +++++++++++++++
 src/window/windowManager.js                   |   32 +-
 22 files changed, 4056 insertions(+), 6 deletions(-)
 create mode 100644 pickleglass_web/app/research/page.tsx
 create mode 100644 src/features/research/repositories/questionResponse/index.js
 create mode 100644 src/features/research/repositories/questionResponse/sqlite.repository.js
 create mode 100644 src/features/research/repositories/researchQuestion/index.js
 create mode 100644 src/features/research/repositories/researchQuestion/sqlite.repository.js
 create mode 100644 src/features/research/repositories/researchSession/index.js
 create mode 100644 src/features/research/repositories/researchSession/sqlite.repository.js
 create mode 100644 src/features/research/repositories/researchStudy/index.js
 create mode 100644 src/features/research/repositories/researchStudy/sqlite.repository.js
 create mode 100644 src/features/research/researchService.js
 create mode 100644 src/ui/research/ResearchView.js

diff --git a/pickleglass_web/app/research/page.tsx b/pickleglass_web/app/research/page.tsx
new file mode 100644
index 0000000..663a139
--- /dev/null
+++ b/pickleglass_web/app/research/page.tsx
@@ -0,0 +1,559 @@
+'use client'
+
+import { useState, useEffect } from 'react'
+import { ChevronRightIcon, PlayIcon, StopIcon, ChartBarIcon, UserGroupIcon, ClipboardDocumentListIcon, PlusIcon } from '@heroicons/react/24/outline'
+
+interface ResearchStudy {
+  id: string
+  title: string
+  description: string
+  research_type: string
+  methodology: string
+  status: string
+  created_at: number
+  updated_at: number
+}
+
+interface StudyQuestion {
+  id: string
+  question_text: string
+  category: string
+  priority: string
+  is_required: boolean
+}
+
+interface SessionReport {
+  session: any
+  study: ResearchStudy
+  responses: any[]
+}
+
+export default function ResearchPage() {
+  const [studies, setStudies] = useState<ResearchStudy[]>([])
+  const [selectedStudy, setSelectedStudy] = useState<ResearchStudy | null>(null)
+  const [questions, setQuestions] = useState<StudyQuestion[]>([])
+  const [sessionReports, setSessionReports] = useState<SessionReport[]>([])
+  const [view, setView] = useState<'overview' | 'study' | 'report'>('overview')
+  const [isLoading, setIsLoading] = useState(true)
+  const [showCreateForm, setShowCreateForm] = useState(false)
+
+  useEffect(() => {
+    loadStudies()
+  }, [])
+
+  const loadStudies = async () => {
+    try {
+      setIsLoading(true)
+      // Simulate API call - in real implementation this would call the backend
+      const response = await fetch('/api/research/studies')
+      if (response.ok) {
+        const data = await response.json()
+        setStudies(data)
+      }
+    } catch (error) {
+      console.error('Failed to load studies:', error)
+    } finally {
+      setIsLoading(false)
+    }
+  }
+
+  const loadStudyDetails = async (study: ResearchStudy) => {
+    try {
+      setSelectedStudy(study)
+      setView('study')
+      
+      // Load questions and session reports
+      const [questionsRes, reportsRes] = await Promise.all([
+        fetch(`/api/research/studies/${study.id}/questions`),
+        fetch(`/api/research/studies/${study.id}/reports`)
+      ])
+      
+      if (questionsRes.ok) {
+        const questionsData = await questionsRes.json()
+        setQuestions(questionsData)
+      }
+      
+      if (reportsRes.ok) {
+        const reportsData = await reportsRes.json()
+        setSessionReports(reportsData)
+      }
+    } catch (error) {
+      console.error('Failed to load study details:', error)
+    }
+  }
+
+  const createStudy = async (studyData: any) => {
+    try {
+      const response = await fetch('/api/research/studies', {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify(studyData)
+      })
+      
+      if (response.ok) {
+        await loadStudies()
+        setShowCreateForm(false)
+      }
+    } catch (error) {
+      console.error('Failed to create study:', error)
+    }
+  }
+
+  const getStatusColor = (status: string) => {
+    const colors = {
+      draft: 'bg-gray-100 text-gray-800',
+      active: 'bg-green-100 text-green-800',
+      completed: 'bg-blue-100 text-blue-800',
+      archived: 'bg-orange-100 text-orange-800'
+    }
+    return colors[status as keyof typeof colors] || colors.draft
+  }
+
+  const getTypeIcon = (type: string) => {
+    const icons = {
+      user_interview: UserGroupIcon,
+      usability_test: ClipboardDocumentListIcon,
+      focus_group: UserGroupIcon
+    }
+    const Icon = icons[type as keyof typeof icons] || UserGroupIcon
+    return <Icon className="h-5 w-5" />
+  }
+
+  if (isLoading) {
+    return (
+      <div className="min-h-screen flex items-center justify-center">
+        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500"></div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="min-h-screen bg-gray-50">
+      {/* Header */}
+      <div className="bg-white shadow">
+        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
+          <div className="flex justify-between items-center py-6">
+            <div>
+              <h1 className="text-3xl font-bold text-gray-900">UX Research Studio</h1>
+              <p className="mt-2 text-sm text-gray-600">
+                Manage research studies, track interview progress, and analyze insights
+              </p>
+            </div>
+            
+            <div className="flex space-x-3">
+              {view !== 'overview' && (
+                <button
+                  onClick={() => setView('overview')}
+                  className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
+                >
+                  ‚Üê Back to Studies
+                </button>
+              )}
+              
+              {view === 'overview' && (
+                <button
+                  onClick={() => setShowCreateForm(true)}
+                  className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
+                >
+                  <PlusIcon className="h-4 w-4 mr-2" />
+                  New Study
+                </button>
+              )}
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
+        {view === 'overview' && (
+          <StudiesOverview 
+            studies={studies} 
+            onStudySelect={loadStudyDetails}
+            showCreateForm={showCreateForm}
+            onCreateStudy={createStudy}
+            onCloseCreateForm={() => setShowCreateForm(false)}
+          />
+        )}
+        
+        {view === 'study' && selectedStudy && (
+          <StudyDetails 
+            study={selectedStudy} 
+            questions={questions}
+            sessionReports={sessionReports}
+            onViewReport={(report) => {
+              setView('report')
+            }}
+          />
+        )}
+      </div>
+    </div>
+  )
+}
+
+function StudiesOverview({ 
+  studies, 
+  onStudySelect, 
+  showCreateForm, 
+  onCreateStudy, 
+  onCloseCreateForm 
+}: {
+  studies: ResearchStudy[]
+  onStudySelect: (study: ResearchStudy) => void
+  showCreateForm: boolean
+  onCreateStudy: (data: any) => void
+  onCloseCreateForm: () => void
+}) {
+  const [formData, setFormData] = useState({
+    title: '',
+    description: '',
+    research_type: 'user_interview',
+    methodology: 'semi_structured',
+    participant_profile: '',
+    goals: ''
+  })
+
+  const handleSubmit = (e: React.FormEvent) => {
+    e.preventDefault()
+    onCreateStudy(formData)
+    setFormData({
+      title: '',
+      description: '',
+      research_type: 'user_interview',
+      methodology: 'semi_structured',
+      participant_profile: '',
+      goals: ''
+    })
+  }
+
+  return (
+    <div className="space-y-6">
+      {/* Stats Cards */}
+      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
+        <div className="bg-white overflow-hidden shadow rounded-lg">
+          <div className="p-5">
+            <div className="flex items-center">
+              <div className="flex-shrink-0">
+                <ClipboardDocumentListIcon className="h-6 w-6 text-gray-400" />
+              </div>
+              <div className="ml-5 w-0 flex-1">
+                <dl>
+                  <dt className="text-sm font-medium text-gray-500 truncate">Total Studies</dt>
+                  <dd className="text-lg font-medium text-gray-900">{studies.length}</dd>
+                </dl>
+              </div>
+            </div>
+          </div>
+        </div>
+
+        <div className="bg-white overflow-hidden shadow rounded-lg">
+          <div className="p-5">
+            <div className="flex items-center">
+              <div className="flex-shrink-0">
+                <PlayIcon className="h-6 w-6 text-green-400" />
+              </div>
+              <div className="ml-5 w-0 flex-1">
+                <dl>
+                  <dt className="text-sm font-medium text-gray-500 truncate">Active Studies</dt>
+                  <dd className="text-lg font-medium text-gray-900">
+                    {studies.filter(s => s.status === 'active').length}
+                  </dd>
+                </dl>
+              </div>
+            </div>
+          </div>
+        </div>
+
+        <div className="bg-white overflow-hidden shadow rounded-lg">
+          <div className="p-5">
+            <div className="flex items-center">
+              <div className="flex-shrink-0">
+                <UserGroupIcon className="h-6 w-6 text-blue-400" />
+              </div>
+              <div className="ml-5 w-0 flex-1">
+                <dl>
+                  <dt className="text-sm font-medium text-gray-500 truncate">Interviews</dt>
+                  <dd className="text-lg font-medium text-gray-900">
+                    {studies.filter(s => s.research_type === 'user_interview').length}
+                  </dd>
+                </dl>
+              </div>
+            </div>
+          </div>
+        </div>
+
+        <div className="bg-white overflow-hidden shadow rounded-lg">
+          <div className="p-5">
+            <div className="flex items-center">
+              <div className="flex-shrink-0">
+                <ChartBarIcon className="h-6 w-6 text-purple-400" />
+              </div>
+              <div className="ml-5 w-0 flex-1">
+                <dl>
+                  <dt className="text-sm font-medium text-gray-500 truncate">Completed</dt>
+                  <dd className="text-lg font-medium text-gray-900">
+                    {studies.filter(s => s.status === 'completed').length}
+                  </dd>
+                </dl>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      {/* Create Study Form */}
+      {showCreateForm && (
+        <div className="bg-white shadow rounded-lg p-6">
+          <form onSubmit={handleSubmit} className="space-y-6">
+            <div>
+              <h3 className="text-lg font-medium text-gray-900 mb-4">Create New Research Study</h3>
+              
+              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
+                <div>
+                  <label className="block text-sm font-medium text-gray-700">Study Title</label>
+                  <input
+                    type="text"
+                    required
+                    value={formData.title}
+                    onChange={(e) => setFormData({...formData, title: e.target.value})}
+                    className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
+                    placeholder="e.g., Mobile Banking App Usability Study"
+                  />
+                </div>
+                
+                <div>
+                  <label className="block text-sm font-medium text-gray-700">Research Type</label>
+                  <select
+                    value={formData.research_type}
+                    onChange={(e) => setFormData({...formData, research_type: e.target.value})}
+                    className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
+                  >
+                    <option value="user_interview">User Interview</option>
+                    <option value="usability_test">Usability Test</option>
+                    <option value="focus_group">Focus Group</option>
+                  </select>
+                </div>
+              </div>
+              
+              <div className="mt-4">
+                <label className="block text-sm font-medium text-gray-700">Description</label>
+                <textarea
+                  value={formData.description}
+                  onChange={(e) => setFormData({...formData, description: e.target.value})}
+                  rows={3}
+                  className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
+                  placeholder="Brief description of the study objectives and scope"
+                />
+              </div>
+              
+              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
+                <div>
+                  <label className="block text-sm font-medium text-gray-700">Methodology</label>
+                  <select
+                    value={formData.methodology}
+                    onChange={(e) => setFormData({...formData, methodology: e.target.value})}
+                    className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
+                  >
+                    <option value="semi_structured">Semi-structured</option>
+                    <option value="structured">Structured</option>
+                    <option value="unstructured">Unstructured</option>
+                  </select>
+                </div>
+                
+                <div>
+                  <label className="block text-sm font-medium text-gray-700">Goals</label>
+                  <textarea
+                    value={formData.goals}
+                    onChange={(e) => setFormData({...formData, goals: e.target.value})}
+                    rows={2}
+                    className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
+                    placeholder="Key research questions and objectives"
+                  />
+                </div>
+              </div>
+            </div>
+            
+            <div className="flex justify-end space-x-3">
+              <button
+                type="button"
+                onClick={onCloseCreateForm}
+                className="px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
+              >
+                Cancel
+              </button>
+              <button
+                type="submit"
+                className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
+              >
+                Create Study
+              </button>
+            </div>
+          </form>
+        </div>
+      )}
+
+      {/* Studies List */}
+      <div className="bg-white shadow overflow-hidden sm:rounded-md">
+        <ul className="divide-y divide-gray-200">
+          {studies.map((study) => (
+            <li key={study.id}>
+              <button
+                onClick={() => onStudySelect(study)}
+                className="w-full text-left hover:bg-gray-50 focus:outline-none focus:bg-gray-50 transition duration-150 ease-in-out"
+              >
+                <div className="px-4 py-4 sm:px-6">
+                  <div className="flex items-center justify-between">
+                    <div className="flex items-center">
+                      <div className="flex-shrink-0 mr-3">
+                        {getTypeIcon(study.research_type)}
+                      </div>
+                      <div>
+                        <p className="text-sm font-medium text-blue-600">{study.title}</p>
+                        <p className="text-sm text-gray-500">{study.description}</p>
+                      </div>
+                    </div>
+                    <div className="flex items-center space-x-2">
+                      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusColor(study.status)}`}>
+                        {study.status}
+                      </span>
+                      <ChevronRightIcon className="h-5 w-5 text-gray-400" />
+                    </div>
+                  </div>
+                  <div className="mt-2 sm:flex sm:justify-between">
+                    <div className="sm:flex">
+                      <p className="flex items-center text-sm text-gray-500">
+                        {study.research_type.replace('_', ' ')} ‚Ä¢ {study.methodology}
+                      </p>
+                    </div>
+                    <div className="mt-2 flex items-center text-sm text-gray-500 sm:mt-0">
+                      <p>
+                        Updated {new Date(study.updated_at * 1000).toLocaleDateString()}
+                      </p>
+                    </div>
+                  </div>
+                </div>
+              </button>
+            </li>
+          ))}
+        </ul>
+      </div>
+    </div>
+  )
+}
+
+function StudyDetails({ 
+  study, 
+  questions, 
+  sessionReports, 
+  onViewReport 
+}: {
+  study: ResearchStudy
+  questions: StudyQuestion[]
+  sessionReports: SessionReport[]
+  onViewReport: (report: SessionReport) => void
+}) {
+  return (
+    <div className="space-y-6">
+      {/* Study Header */}
+      <div className="bg-white shadow rounded-lg p-6">
+        <div className="flex justify-between items-start">
+          <div>
+            <h2 className="text-2xl font-bold text-gray-900">{study.title}</h2>
+            <p className="mt-2 text-gray-600">{study.description}</p>
+            <div className="mt-4 flex space-x-4">
+              <span className="text-sm text-gray-500">
+                <strong>Type:</strong> {study.research_type.replace('_', ' ')}
+              </span>
+              <span className="text-sm text-gray-500">
+                <strong>Methodology:</strong> {study.methodology}
+              </span>
+              <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusColor(study.status)}`}>
+                {study.status}
+              </span>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      {/* Questions Overview */}
+      <div className="bg-white shadow rounded-lg p-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-4">Interview Questions ({questions.length})</h3>
+        <div className="space-y-3">
+          {questions.map((question, index) => (
+            <div key={question.id} className="border-l-4 border-blue-400 pl-4">
+              <p className="text-sm font-medium text-gray-900">{question.question_text}</p>
+              <div className="mt-1 flex space-x-2">
+                <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
+                  {question.category}
+                </span>
+                <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${
+                  question.priority === 'high' ? 'bg-red-100 text-red-800' :
+                  question.priority === 'medium' ? 'bg-yellow-100 text-yellow-800' :
+                  'bg-green-100 text-green-800'
+                }`}>
+                  {question.priority}
+                </span>
+                {question.is_required && (
+                  <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
+                    required
+                  </span>
+                )}
+              </div>
+            </div>
+          ))}
+        </div>
+      </div>
+
+      {/* Session Reports */}
+      <div className="bg-white shadow rounded-lg p-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-4">Session Reports ({sessionReports.length})</h3>
+        {sessionReports.length === 0 ? (
+          <p className="text-gray-500">No sessions completed yet.</p>
+        ) : (
+          <div className="space-y-3">
+            {sessionReports.map((report, index) => (
+              <div key={index} className="border border-gray-200 rounded-lg p-4">
+                <div className="flex justify-between items-start">
+                  <div>
+                    <p className="font-medium">Session {index + 1}</p>
+                    <p className="text-sm text-gray-500">
+                      Participant: {report.session.participant_id}
+                    </p>
+                    <p className="text-sm text-gray-500">
+                      Quality Score: {(report.session.session_quality_score * 100).toFixed(0)}%
+                    </p>
+                  </div>
+                  <button
+                    onClick={() => onViewReport(report)}
+                    className="inline-flex items-center px-3 py-1 border border-transparent text-sm font-medium rounded-md text-blue-600 bg-blue-100 hover:bg-blue-200"
+                  >
+                    View Report
+                  </button>
+                </div>
+              </div>
+            ))}
+          </div>
+        )}
+      </div>
+    </div>
+  )
+}
+
+function getStatusColor(status: string) {
+  const colors = {
+    draft: 'bg-gray-100 text-gray-800',
+    active: 'bg-green-100 text-green-800',
+    completed: 'bg-blue-100 text-blue-800',
+    archived: 'bg-orange-100 text-orange-800'
+  }
+  return colors[status as keyof typeof colors] || colors.draft
+}
+
+function getTypeIcon(type: string) {
+  const icons = {
+    user_interview: UserGroupIcon,
+    usability_test: ClipboardDocumentListIcon,
+    focus_group: UserGroupIcon
+  }
+  const Icon = icons[type as keyof typeof icons] || UserGroupIcon
+  return <Icon className="h-5 w-5" />
+} 
\ No newline at end of file
diff --git a/pickleglass_web/package-lock.json b/pickleglass_web/package-lock.json
index f1d6fa0..69c80cf 100644
--- a/pickleglass_web/package-lock.json
+++ b/pickleglass_web/package-lock.json
@@ -9,6 +9,7 @@
       "version": "0.1.0",
       "dependencies": {
         "@headlessui/react": "^1.7.17",
+        "@heroicons/react": "^2.2.0",
         "autoprefixer": "^10.4.16",
         "axios": "^1.6.0",
         "firebase": "^11.10.0",
@@ -794,6 +795,15 @@
         "react-dom": "^16 || ^17 || ^18"
       }
     },
+    "node_modules/@heroicons/react": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/@heroicons/react/-/react-2.2.0.tgz",
+      "integrity": "sha512-LMcepvRaS9LYHJGsF0zzmgKCUim/X3N/DQKc4jepAXJ7l8QxJ1PmxJzqplF2Z3FE4PqBAIGyJAQ/w4B5dsqbtQ==",
+      "license": "MIT",
+      "peerDependencies": {
+        "react": ">= 16 || ^19.0.0-rc"
+      }
+    },
     "node_modules/@humanwhocodes/config-array": {
       "version": "0.13.0",
       "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.13.0.tgz",
diff --git a/pickleglass_web/package.json b/pickleglass_web/package.json
index bf7c1b2..b6b5e32 100644
--- a/pickleglass_web/package.json
+++ b/pickleglass_web/package.json
@@ -10,6 +10,7 @@
   },
   "dependencies": {
     "@headlessui/react": "^1.7.17",
+    "@heroicons/react": "^2.2.0",
     "autoprefixer": "^10.4.16",
     "axios": "^1.6.0",
     "firebase": "^11.10.0",
diff --git a/src/bridge/featureBridge.js b/src/bridge/featureBridge.js
index 4527ced..c296b06 100644
--- a/src/bridge/featureBridge.js
+++ b/src/bridge/featureBridge.js
@@ -1,5 +1,6 @@
 // src/bridge/featureBridge.js
 const { ipcMain, app, BrowserWindow } = require('electron');
+const internalBridge = require('./internalBridge');
 const settingsService = require('../features/settings/settingsService');
 const authService = require('../features/common/services/authService');
 const whisperService = require('../features/common/services/whisperService');
@@ -12,6 +13,7 @@ const askService = require('../features/ask/askService');
 const listenService = require('../features/listen/listenService');
 const permissionService = require('../features/common/services/permissionService');
 const encryptionService = require('../features/common/services/encryptionService');
+const researchService = require('../features/research/researchService');
 
 module.exports = {
   // RendererÎ°úÎ∂ÄÌÑ∞Ïùò ÏöîÏ≤≠ÏùÑ ÏàòÏã†ÌïòÍ≥† ÏÑúÎπÑÏä§Î°ú Ï†ÑÎã¨
@@ -120,6 +122,37 @@ module.exports = {
     ipcMain.handle('model:get-provider-config', () => modelStateService.getProviderConfig());
     ipcMain.handle('model:re-initialize-state', async () => await modelStateService.initialize());
 
+    // Research Service
+    ipcMain.handle('research:create-study', async (event, studyData) => await researchService.createStudy(studyData));
+    ipcMain.handle('research:get-all-studies', async () => await researchService.getAllStudies());
+    ipcMain.handle('research:get-study', async (event, studyId) => await researchService.getStudy(studyId));
+    ipcMain.handle('research:update-study', async (event, { studyId, updateData }) => await researchService.updateStudy(studyId, updateData));
+    ipcMain.handle('research:delete-study', async (event, studyId) => await researchService.deleteStudy(studyId));
+    
+    ipcMain.handle('research:add-question', async (event, { studyId, questionData }) => await researchService.addQuestion(studyId, questionData));
+    ipcMain.handle('research:get-study-questions', async (event, studyId) => await researchService.getStudyQuestions(studyId));
+    ipcMain.handle('research:update-question', async (event, { questionId, updateData }) => await researchService.updateQuestion(questionId, updateData));
+    ipcMain.handle('research:delete-question', async (event, questionId) => await researchService.deleteQuestion(questionId));
+    
+    ipcMain.handle('research:start-session', async (event, { studyId, participantData }) => await researchService.startResearchSession(studyId, participantData));
+    ipcMain.handle('research:end-session', async () => await researchService.endResearchSession());
+    ipcMain.handle('research:get-session-status', async () => researchService.getSessionStatus());
+    ipcMain.handle('research:get-session-report', async (event, sessionId) => await researchService.getSessionReport(sessionId));
+    
+    // Follow-up Question Management
+    ipcMain.handle('research:mark-followup-asked', async (event, { questionId, response }) => {
+        return researchService.markFollowUpQuestionAsked(questionId, response);
+    });
+    ipcMain.handle('research:get-followup-metrics', async () => {
+        return researchService.followUpQuestionMetrics;
+    });
+
+    // Research navigation handler
+    ipcMain.handle('research:navigate-to-research', async () => {
+        // Request navigation with toggle logic handled by window manager
+        internalBridge.emit('window:requestNavigation', { view: 'toggle-research' });
+    });
+
     // LocalAIManager Ïù¥Î≤§Ìä∏Î•º Î™®Îì† ÏúàÎèÑÏö∞Ïóê Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
     localAIManager.on('install-progress', (service, data) => {
       const event = { service, ...data };
@@ -170,6 +203,36 @@ module.exports = {
     // Ï£ºÍ∏∞Ï†Å ÏÉÅÌÉú ÎèôÍ∏∞Ìôî ÏãúÏûë
     localAIManager.startPeriodicSync();
 
+    // ResearchService Ïù¥Î≤§Ìä∏Î•º Î™®Îì† ÏúàÎèÑÏö∞Ïóê Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
+    researchService.on('session-started', (data) => {
+      BrowserWindow.getAllWindows().forEach(win => {
+        if (win && !win.isDestroyed()) {
+          win.webContents.send('research:session-started', data);
+        }
+      });
+    });
+    researchService.on('session-ended', (data) => {
+      BrowserWindow.getAllWindows().forEach(win => {
+        if (win && !win.isDestroyed()) {
+          win.webContents.send('research:session-ended', data);
+        }
+      });
+    });
+    researchService.on('analysis-update', (data) => {
+      BrowserWindow.getAllWindows().forEach(win => {
+        if (win && !win.isDestroyed()) {
+          win.webContents.send('research:analysis-update', data);
+        }
+      });
+    });
+    researchService.on('followup-questions-expired', (data) => {
+      BrowserWindow.getAllWindows().forEach(win => {
+        if (win && !win.isDestroyed()) {
+          win.webContents.send('research:followup-expired', data);
+        }
+      });
+    });
+
     // ModelStateService Ïù¥Î≤§Ìä∏Î•º Î™®Îì† ÏúàÎèÑÏö∞Ïóê Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
     modelStateService.on('state-updated', (state) => {
       BrowserWindow.getAllWindows().forEach(win => {
diff --git a/src/features/common/config/schema.js b/src/features/common/config/schema.js
index 15af678..860188c 100644
--- a/src/features/common/config/schema.js
+++ b/src/features/common/config/schema.js
@@ -114,6 +114,77 @@ const LATEST_SCHEMA = {
             { name: 'uid', type: 'TEXT PRIMARY KEY' },
             { name: 'keychain_completed', type: 'INTEGER DEFAULT 0' }
         ]
+    },
+    
+    // UX Research Extension Tables
+    research_studies: {
+        columns: [
+            { name: 'id', type: 'TEXT PRIMARY KEY' },
+            { name: 'uid', type: 'TEXT NOT NULL' },
+            { name: 'title', type: 'TEXT NOT NULL' },
+            { name: 'description', type: 'TEXT' },
+            { name: 'research_type', type: 'TEXT DEFAULT \'user_interview\'' }, // user_interview, usability_test, focus_group
+            { name: 'methodology', type: 'TEXT' }, // structured, semi-structured, unstructured
+            { name: 'participant_profile', type: 'TEXT' },
+            { name: 'goals', type: 'TEXT' },
+            { name: 'context', type: 'TEXT' },
+            { name: 'status', type: 'TEXT DEFAULT \'draft\'' }, // draft, active, completed, archived
+            { name: 'created_at', type: 'INTEGER' },
+            { name: 'updated_at', type: 'INTEGER' },
+            { name: 'sync_state', type: 'TEXT DEFAULT \'clean\'' }
+        ]
+    },
+    
+    research_questions: {
+        columns: [
+            { name: 'id', type: 'TEXT PRIMARY KEY' },
+            { name: 'study_id', type: 'TEXT NOT NULL' },
+            { name: 'question_text', type: 'TEXT NOT NULL' },
+            { name: 'question_type', type: 'TEXT DEFAULT \'open\'' }, // open, closed, follow_up, probe
+            { name: 'category', type: 'TEXT' }, // background, behavior, attitude, demographic
+            { name: 'priority', type: 'TEXT DEFAULT \'medium\'' }, // high, medium, low
+            { name: 'order_index', type: 'INTEGER' },
+            { name: 'is_required', type: 'INTEGER DEFAULT 0' },
+            { name: 'follow_up_hints', type: 'TEXT' }, // JSON array of suggested follow-ups
+            { name: 'created_at', type: 'INTEGER' },
+            { name: 'sync_state', type: 'TEXT DEFAULT \'clean\'' }
+        ]
+    },
+    
+    question_responses: {
+        columns: [
+            { name: 'id', type: 'TEXT PRIMARY KEY' },
+            { name: 'session_id', type: 'TEXT NOT NULL' },
+            { name: 'question_id', type: 'TEXT NOT NULL' },
+            { name: 'transcript_segment_start', type: 'INTEGER' }, // timestamp when response started
+            { name: 'transcript_segment_end', type: 'INTEGER' }, // timestamp when response ended
+            { name: 'response_text', type: 'TEXT' }, // extracted relevant transcript
+            { name: 'completeness_score', type: 'REAL DEFAULT 0.0' }, // 0.0-1.0 how complete the answer is
+            { name: 'sentiment', type: 'TEXT' }, // positive, negative, neutral, mixed
+            { name: 'key_insights', type: 'TEXT' }, // JSON array of insights
+            { name: 'follow_up_needed', type: 'INTEGER DEFAULT 0' },
+            { name: 'ai_confidence', type: 'REAL DEFAULT 0.0' }, // AI confidence in the mapping
+            { name: 'status', type: 'TEXT DEFAULT \'partial\'' }, // not_asked, partial, complete, needs_clarification
+            { name: 'created_at', type: 'INTEGER' },
+            { name: 'updated_at', type: 'INTEGER' },
+            { name: 'sync_state', type: 'TEXT DEFAULT \'clean\'' }
+        ]
+    },
+    
+    research_sessions: {
+        columns: [
+            { name: 'session_id', type: 'TEXT PRIMARY KEY' },
+            { name: 'study_id', type: 'TEXT NOT NULL' },
+            { name: 'participant_id', type: 'TEXT' },
+            { name: 'participant_notes', type: 'TEXT' },
+            { name: 'session_notes', type: 'TEXT' },
+            { name: 'research_mode', type: 'TEXT DEFAULT \'live\'' }, // live, review, analysis
+            { name: 'questions_asked', type: 'INTEGER DEFAULT 0' },
+            { name: 'questions_completed', type: 'INTEGER DEFAULT 0' },
+            { name: 'session_quality_score', type: 'REAL DEFAULT 0.0' },
+            { name: 'created_at', type: 'INTEGER' },
+            { name: 'sync_state', type: 'TEXT DEFAULT \'clean\'' }
+        ]
     }
 };
 
diff --git a/src/features/common/services/sqliteClient.js b/src/features/common/services/sqliteClient.js
index 7d37e40..5f5680a 100644
--- a/src/features/common/services/sqliteClient.js
+++ b/src/features/common/services/sqliteClient.js
@@ -225,6 +225,7 @@ class SQLiteClient {
             ['meetings', 'Meetings', 'You are a meeting assistant. Your goal is to help the user capture key information during meetings and follow up effectively.\n\nYou help capture meeting notes, track action items, identify key decisions, and summarize important points discussed during meetings.', 1],
             ['sales', 'Sales', 'You are a real-time AI sales assistant, and your goal is to help the user close deals during sales interactions.\n\nYou provide real-time sales support, suggest responses to objections, help identify customer needs, and recommend strategies to advance deals.', 1],
             ['recruiting', 'Recruiting', 'You are a recruiting assistant. Your goal is to help the user interview candidates and evaluate talent effectively.\n\nYou help evaluate candidates, suggest interview questions, analyze responses, and provide insights about candidate fit for positions.', 1],
+            ['ux_research', 'UX Research', 'You are a UX research assistant specialized in user interviews, usability testing, and design research.\n\nYou help analyze user behavior, identify pain points, suggest follow-up questions, and extract actionable insights for product improvement. You understand research methodologies like task analysis, user journey mapping, and behavioral observation.', 1],
             ['customer-support', 'Customer Support', 'You are a customer support assistant. Your goal is to help resolve customer issues efficiently and thoroughly.\n\nYou help diagnose customer problems, suggest solutions, provide step-by-step troubleshooting guidance, and ensure customer satisfaction.', 1],
         ];
 
diff --git a/src/features/listen/listenService.js b/src/features/listen/listenService.js
index 1533588..9c74ce5 100644
--- a/src/features/listen/listenService.js
+++ b/src/features/listen/listenService.js
@@ -5,6 +5,7 @@ const authService = require('../common/services/authService');
 const sessionRepository = require('../common/repositories/session');
 const sttRepository = require('./stt/repositories');
 const internalBridge = require('../../bridge/internalBridge');
+const researchService = require('../research/researchService');
 
 class ListenService {
     constructor() {
@@ -104,6 +105,14 @@ class ListenService {
         
         // Add to summary service for analysis
         this.summaryService.addConversationTurn(speaker, text);
+        
+        // Send to research service for question tracking (if research session is active)
+        try {
+            await researchService.processTranscriptSegment(speaker, text, Date.now());
+        } catch (error) {
+            console.error('[ListenService] Failed to process transcript for research:', error);
+            // Don't break the transcription flow if research analysis fails
+        }
     }
 
     async saveConversationTurn(speaker, transcription) {
diff --git a/src/features/research/repositories/questionResponse/index.js b/src/features/research/repositories/questionResponse/index.js
new file mode 100644
index 0000000..79611f5
--- /dev/null
+++ b/src/features/research/repositories/questionResponse/index.js
@@ -0,0 +1,9 @@
+const sqliteRepository = require('./sqlite.repository');
+
+module.exports = {
+    createOrUpdate: (response) => sqliteRepository.createOrUpdate(response),
+    getById: (responseId) => sqliteRepository.getById(responseId),
+    getBySessionId: (sessionId) => sqliteRepository.getBySessionId(sessionId),
+    deleteByQuestionId: (questionId) => sqliteRepository.deleteByQuestionId(questionId),
+    deleteByStudyId: (studyId) => sqliteRepository.deleteByStudyId(studyId)
+}; 
\ No newline at end of file
diff --git a/src/features/research/repositories/questionResponse/sqlite.repository.js b/src/features/research/repositories/questionResponse/sqlite.repository.js
new file mode 100644
index 0000000..8bb591a
--- /dev/null
+++ b/src/features/research/repositories/questionResponse/sqlite.repository.js
@@ -0,0 +1,118 @@
+const sqliteClient = require('../../../common/services/sqliteClient');
+
+function createOrUpdate(response) {
+    const db = sqliteClient.getDb();
+    
+    const query = `
+        INSERT INTO question_responses (
+            id, session_id, question_id, transcript_segment_start, 
+            transcript_segment_end, response_text, completeness_score, 
+            sentiment, key_insights, follow_up_needed, ai_confidence, 
+            status, created_at, updated_at
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+        ON CONFLICT(id) DO UPDATE SET
+            transcript_segment_start = excluded.transcript_segment_start,
+            transcript_segment_end = excluded.transcript_segment_end,
+            response_text = excluded.response_text,
+            completeness_score = excluded.completeness_score,
+            sentiment = excluded.sentiment,
+            key_insights = excluded.key_insights,
+            follow_up_needed = excluded.follow_up_needed,
+            ai_confidence = excluded.ai_confidence,
+            status = excluded.status,
+            updated_at = excluded.updated_at
+    `;
+    
+    try {
+        db.prepare(query).run(
+            response.id,
+            response.session_id,
+            response.question_id,
+            response.transcript_segment_start || null,
+            response.transcript_segment_end || null,
+            response.response_text || null,
+            response.completeness_score || 0.0,
+            response.sentiment || null,
+            response.key_insights || null,
+            response.follow_up_needed || 0,
+            response.ai_confidence || 0.0,
+            response.status || 'not_asked',
+            response.created_at,
+            response.updated_at
+        );
+        
+        return getById(response.id);
+    } catch (err) {
+        console.error('[QuestionResponse SQLite] Failed to create/update response:', err);
+        throw err;
+    }
+}
+
+function getById(responseId) {
+    const db = sqliteClient.getDb();
+    const query = `SELECT * FROM question_responses WHERE id = ?`;
+    
+    try {
+        return db.prepare(query).get(responseId);
+    } catch (err) {
+        console.error('[QuestionResponse SQLite] Failed to get response by ID:', err);
+        throw err;
+    }
+}
+
+function getBySessionId(sessionId) {
+    const db = sqliteClient.getDb();
+    const query = `
+        SELECT qr.*, rq.question_text, rq.category, rq.priority
+        FROM question_responses qr
+        JOIN research_questions rq ON qr.question_id = rq.id
+        WHERE qr.session_id = ?
+        ORDER BY rq.order_index ASC
+    `;
+    
+    try {
+        return db.prepare(query).all(sessionId);
+    } catch (err) {
+        console.error('[QuestionResponse SQLite] Failed to get responses by session ID:', err);
+        throw err;
+    }
+}
+
+function deleteByQuestionId(questionId) {
+    const db = sqliteClient.getDb();
+    const query = `DELETE FROM question_responses WHERE question_id = ?`;
+    
+    try {
+        const result = db.prepare(query).run(questionId);
+        return { success: true, deletedCount: result.changes };
+    } catch (err) {
+        console.error('[QuestionResponse SQLite] Failed to delete responses by question ID:', err);
+        throw err;
+    }
+}
+
+function deleteByStudyId(studyId) {
+    const db = sqliteClient.getDb();
+    const query = `
+        DELETE FROM question_responses 
+        WHERE question_id IN (
+            SELECT id FROM research_questions WHERE study_id = ?
+        )
+    `;
+    
+    try {
+        const result = db.prepare(query).run(studyId);
+        return { success: true, deletedCount: result.changes };
+    } catch (err) {
+        console.error('[QuestionResponse SQLite] Failed to delete responses by study ID:', err);
+        throw err;
+    }
+}
+
+module.exports = {
+    createOrUpdate,
+    getById,
+    getBySessionId,
+    deleteByQuestionId,
+    deleteByStudyId
+}; 
\ No newline at end of file
diff --git a/src/features/research/repositories/researchQuestion/index.js b/src/features/research/repositories/researchQuestion/index.js
new file mode 100644
index 0000000..e9573b4
--- /dev/null
+++ b/src/features/research/repositories/researchQuestion/index.js
@@ -0,0 +1,13 @@
+const sqliteRepository = require('./sqlite.repository');
+
+// Simple wrapper - questions are tied to studies which already have user context
+const researchQuestionRepositoryAdapter = {
+    create: (question) => sqliteRepository.create(question),
+    getById: (questionId) => sqliteRepository.getById(questionId),
+    getByStudyId: (studyId) => sqliteRepository.getByStudyId(studyId),
+    update: (questionId, updateData) => sqliteRepository.update(questionId, updateData),
+    delete: (questionId) => sqliteRepository.delete(questionId),
+    deleteByStudyId: (studyId) => sqliteRepository.deleteByStudyId(studyId)
+};
+
+module.exports = researchQuestionRepositoryAdapter; 
\ No newline at end of file
diff --git a/src/features/research/repositories/researchQuestion/sqlite.repository.js b/src/features/research/repositories/researchQuestion/sqlite.repository.js
new file mode 100644
index 0000000..ddefe20
--- /dev/null
+++ b/src/features/research/repositories/researchQuestion/sqlite.repository.js
@@ -0,0 +1,122 @@
+const sqliteClient = require('../../../common/services/sqliteClient');
+
+function create(question) {
+    const db = sqliteClient.getDb();
+    
+    const query = `
+        INSERT INTO research_questions (
+            id, study_id, question_text, question_type, category, 
+            priority, order_index, is_required, follow_up_hints, created_at
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `;
+    
+    try {
+        db.prepare(query).run(
+            question.id,
+            question.study_id,
+            question.question_text,
+            question.question_type || 'open',
+            question.category || 'behavior',
+            question.priority || 'medium',
+            question.order_index || 0,
+            question.is_required || 0,
+            question.follow_up_hints || '[]',
+            question.created_at
+        );
+        
+        return getById(question.id);
+    } catch (err) {
+        console.error('[ResearchQuestion SQLite] Failed to create question:', err);
+        throw err;
+    }
+}
+
+function getById(questionId) {
+    const db = sqliteClient.getDb();
+    const query = `SELECT * FROM research_questions WHERE id = ?`;
+    
+    try {
+        return db.prepare(query).get(questionId);
+    } catch (err) {
+        console.error('[ResearchQuestion SQLite] Failed to get question by ID:', err);
+        throw err;
+    }
+}
+
+function getByStudyId(studyId) {
+    const db = sqliteClient.getDb();
+    const query = `
+        SELECT * FROM research_questions 
+        WHERE study_id = ? 
+        ORDER BY order_index ASC, created_at ASC
+    `;
+    
+    try {
+        return db.prepare(query).all(studyId);
+    } catch (err) {
+        console.error('[ResearchQuestion SQLite] Failed to get questions by study ID:', err);
+        throw err;
+    }
+}
+
+function update(questionId, updateData) {
+    const db = sqliteClient.getDb();
+    
+    const setClause = Object.keys(updateData)
+        .map(key => `${key} = ?`)
+        .join(', ');
+    
+    const query = `
+        UPDATE research_questions 
+        SET ${setClause}
+        WHERE id = ?
+    `;
+    
+    const values = [...Object.values(updateData), questionId];
+    
+    try {
+        const result = db.prepare(query).run(...values);
+        if (result.changes === 0) {
+            throw new Error(`Question not found: ${questionId}`);
+        }
+        return getById(questionId);
+    } catch (err) {
+        console.error('[ResearchQuestion SQLite] Failed to update question:', err);
+        throw err;
+    }
+}
+
+function deleteById(questionId) {
+    const db = sqliteClient.getDb();
+    const query = `DELETE FROM research_questions WHERE id = ?`;
+    
+    try {
+        const result = db.prepare(query).run(questionId);
+        return { success: result.changes > 0 };
+    } catch (err) {
+        console.error('[ResearchQuestion SQLite] Failed to delete question:', err);
+        throw err;
+    }
+}
+
+function deleteByStudyId(studyId) {
+    const db = sqliteClient.getDb();
+    const query = `DELETE FROM research_questions WHERE study_id = ?`;
+    
+    try {
+        const result = db.prepare(query).run(studyId);
+        return { success: true, deletedCount: result.changes };
+    } catch (err) {
+        console.error('[ResearchQuestion SQLite] Failed to delete questions by study ID:', err);
+        throw err;
+    }
+}
+
+module.exports = {
+    create,
+    getById,
+    getByStudyId,
+    update,
+    delete: deleteById,
+    deleteByStudyId
+}; 
\ No newline at end of file
diff --git a/src/features/research/repositories/researchSession/index.js b/src/features/research/repositories/researchSession/index.js
new file mode 100644
index 0000000..09df374
--- /dev/null
+++ b/src/features/research/repositories/researchSession/index.js
@@ -0,0 +1,8 @@
+const sqliteRepository = require('./sqlite.repository');
+
+module.exports = {
+    create: (session) => sqliteRepository.create(session),
+    getById: (sessionId) => sqliteRepository.getById(sessionId),
+    update: (sessionId, updateData) => sqliteRepository.update(sessionId, updateData),
+    getByStudyId: (studyId) => sqliteRepository.getByStudyId(studyId)
+}; 
\ No newline at end of file
diff --git a/src/features/research/repositories/researchSession/sqlite.repository.js b/src/features/research/repositories/researchSession/sqlite.repository.js
new file mode 100644
index 0000000..94de140
--- /dev/null
+++ b/src/features/research/repositories/researchSession/sqlite.repository.js
@@ -0,0 +1,95 @@
+const sqliteClient = require('../../../common/services/sqliteClient');
+
+function create(session) {
+    const db = sqliteClient.getDb();
+    
+    const query = `
+        INSERT INTO research_sessions (
+            session_id, study_id, participant_id, participant_notes, 
+            session_notes, research_mode, questions_asked, questions_completed, 
+            session_quality_score, created_at
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `;
+    
+    try {
+        db.prepare(query).run(
+            session.session_id,
+            session.study_id,
+            session.participant_id || null,
+            session.participant_notes || '',
+            session.session_notes || '',
+            session.research_mode || 'live',
+            session.questions_asked || 0,
+            session.questions_completed || 0,
+            session.session_quality_score || 0.0,
+            session.created_at
+        );
+        
+        return getById(session.session_id);
+    } catch (err) {
+        console.error('[ResearchSession SQLite] Failed to create session:', err);
+        throw err;
+    }
+}
+
+function getById(sessionId) {
+    const db = sqliteClient.getDb();
+    const query = `SELECT * FROM research_sessions WHERE session_id = ?`;
+    
+    try {
+        return db.prepare(query).get(sessionId);
+    } catch (err) {
+        console.error('[ResearchSession SQLite] Failed to get session by ID:', err);
+        throw err;
+    }
+}
+
+function update(sessionId, updateData) {
+    const db = sqliteClient.getDb();
+    
+    const setClause = Object.keys(updateData)
+        .map(key => `${key} = ?`)
+        .join(', ');
+    
+    const query = `
+        UPDATE research_sessions 
+        SET ${setClause}
+        WHERE session_id = ?
+    `;
+    
+    const values = [...Object.values(updateData), sessionId];
+    
+    try {
+        const result = db.prepare(query).run(...values);
+        if (result.changes === 0) {
+            throw new Error(`Research session not found: ${sessionId}`);
+        }
+        return getById(sessionId);
+    } catch (err) {
+        console.error('[ResearchSession SQLite] Failed to update session:', err);
+        throw err;
+    }
+}
+
+function getByStudyId(studyId) {
+    const db = sqliteClient.getDb();
+    const query = `
+        SELECT * FROM research_sessions 
+        WHERE study_id = ? 
+        ORDER BY created_at DESC
+    `;
+    
+    try {
+        return db.prepare(query).all(studyId);
+    } catch (err) {
+        console.error('[ResearchSession SQLite] Failed to get sessions by study ID:', err);
+        throw err;
+    }
+}
+
+module.exports = {
+    create,
+    getById,
+    update,
+    getByStudyId
+}; 
\ No newline at end of file
diff --git a/src/features/research/repositories/researchStudy/index.js b/src/features/research/repositories/researchStudy/index.js
new file mode 100644
index 0000000..3fe0c4c
--- /dev/null
+++ b/src/features/research/repositories/researchStudy/index.js
@@ -0,0 +1,58 @@
+const sqliteRepository = require('./sqlite.repository');
+// const firebaseRepository = require('./firebase.repository'); // TODO: Implement Firebase version
+
+let authService = null;
+
+function getAuthService() {
+    if (!authService) {
+        authService = require('../../../common/services/authService');
+    }
+    return authService;
+}
+
+function getBaseRepository() {
+    const service = getAuthService();
+    if (!service) {
+        throw new Error('AuthService could not be loaded for the research study repository.');
+    }
+    const user = service.getCurrentUser();
+    if (user && user.isLoggedIn) {
+        // return firebaseRepository; // TODO: Implement Firebase version
+        return sqliteRepository; // Fallback to SQLite for now
+    }
+    return sqliteRepository;
+}
+
+const researchStudyRepositoryAdapter = {
+    create: (study) => {
+        const uid = getAuthService().getCurrentUserId();
+        return getBaseRepository().create({ uid, ...study });
+    },
+    
+    getById: (studyId) => {
+        const uid = getAuthService().getCurrentUserId();
+        return getBaseRepository().getById(studyId, uid);
+    },
+    
+    getAll: () => {
+        const uid = getAuthService().getCurrentUserId();
+        return getBaseRepository().getAll(uid);
+    },
+    
+    update: (studyId, updateData) => {
+        const uid = getAuthService().getCurrentUserId();
+        return getBaseRepository().update(studyId, updateData, uid);
+    },
+    
+    delete: (studyId) => {
+        const uid = getAuthService().getCurrentUserId();
+        return getBaseRepository().delete(studyId, uid);
+    },
+    
+    getByStatus: (status) => {
+        const uid = getAuthService().getCurrentUserId();
+        return getBaseRepository().getByStatus(status, uid);
+    }
+};
+
+module.exports = researchStudyRepositoryAdapter; 
\ No newline at end of file
diff --git a/src/features/research/repositories/researchStudy/sqlite.repository.js b/src/features/research/repositories/researchStudy/sqlite.repository.js
new file mode 100644
index 0000000..08f7684
--- /dev/null
+++ b/src/features/research/repositories/researchStudy/sqlite.repository.js
@@ -0,0 +1,127 @@
+const sqliteClient = require('../../../common/services/sqliteClient');
+
+function create(study) {
+    const db = sqliteClient.getDb();
+    
+    const query = `
+        INSERT INTO research_studies (
+            id, uid, title, description, research_type, methodology, 
+            participant_profile, goals, context, status, created_at, updated_at
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `;
+    
+    try {
+        db.prepare(query).run(
+            study.id,
+            study.uid,
+            study.title,
+            study.description || '',
+            study.research_type || 'user_interview',
+            study.methodology || 'semi_structured',
+            study.participant_profile || '',
+            study.goals || '',
+            study.context || '',
+            study.status || 'draft',
+            study.created_at,
+            study.updated_at
+        );
+        
+        return getById(study.id, study.uid);
+    } catch (err) {
+        console.error('[ResearchStudy SQLite] Failed to create study:', err);
+        throw err;
+    }
+}
+
+function getById(studyId, uid) {
+    const db = sqliteClient.getDb();
+    const query = `SELECT * FROM research_studies WHERE id = ? AND uid = ?`;
+    
+    try {
+        return db.prepare(query).get(studyId, uid);
+    } catch (err) {
+        console.error('[ResearchStudy SQLite] Failed to get study by ID:', err);
+        throw err;
+    }
+}
+
+function getAll(uid) {
+    const db = sqliteClient.getDb();
+    const query = `
+        SELECT * FROM research_studies 
+        WHERE uid = ? 
+        ORDER BY updated_at DESC
+    `;
+    
+    try {
+        return db.prepare(query).all(uid);
+    } catch (err) {
+        console.error('[ResearchStudy SQLite] Failed to get all studies:', err);
+        throw err;
+    }
+}
+
+function update(studyId, updateData, uid) {
+    const db = sqliteClient.getDb();
+    
+    const setClause = Object.keys(updateData)
+        .map(key => `${key} = ?`)
+        .join(', ');
+    
+    const query = `
+        UPDATE research_studies 
+        SET ${setClause}
+        WHERE id = ? AND uid = ?
+    `;
+    
+    const values = [...Object.values(updateData), studyId, uid];
+    
+    try {
+        const result = db.prepare(query).run(...values);
+        if (result.changes === 0) {
+            throw new Error(`Study not found or not owned by user: ${studyId}`);
+        }
+        return getById(studyId, uid);
+    } catch (err) {
+        console.error('[ResearchStudy SQLite] Failed to update study:', err);
+        throw err;
+    }
+}
+
+function deleteById(studyId, uid) {
+    const db = sqliteClient.getDb();
+    const query = `DELETE FROM research_studies WHERE id = ? AND uid = ?`;
+    
+    try {
+        const result = db.prepare(query).run(studyId, uid);
+        return { success: result.changes > 0 };
+    } catch (err) {
+        console.error('[ResearchStudy SQLite] Failed to delete study:', err);
+        throw err;
+    }
+}
+
+function getByStatus(status, uid) {
+    const db = sqliteClient.getDb();
+    const query = `
+        SELECT * FROM research_studies 
+        WHERE status = ? AND uid = ? 
+        ORDER BY updated_at DESC
+    `;
+    
+    try {
+        return db.prepare(query).all(status, uid);
+    } catch (err) {
+        console.error('[ResearchStudy SQLite] Failed to get studies by status:', err);
+        throw err;
+    }
+}
+
+module.exports = {
+    create,
+    getById,
+    getAll,
+    update,
+    delete: deleteById,
+    getByStatus
+}; 
\ No newline at end of file
diff --git a/src/features/research/researchService.js b/src/features/research/researchService.js
new file mode 100644
index 0000000..768dadd
--- /dev/null
+++ b/src/features/research/researchService.js
@@ -0,0 +1,1403 @@
+const { EventEmitter } = require('events');
+const crypto = require('crypto');
+const modelStateService = require('../common/services/modelStateService');
+const { createLLM } = require('../common/ai/factory');
+const { getSystemPrompt } = require('../common/prompts/promptBuilder');
+const authService = require('../common/services/authService');
+const researchStudyRepository = require('./repositories/researchStudy');
+const researchQuestionRepository = require('./repositories/researchQuestion');
+const questionResponseRepository = require('./repositories/questionResponse');
+const researchSessionRepository = require('./repositories/researchSession');
+const sessionRepository = require('../common/repositories/session');
+const internalBridge = require('../../bridge/internalBridge');
+
+// Utility functions
+function tsSec() { 
+    return Math.floor(Date.now() / 1000); 
+}
+
+function concatClean(a, b) {
+    if (!a) return b;
+    if (!b) return a;
+    return (a + ' ' + b).trim();
+}
+
+class ResearchService extends EventEmitter {
+    constructor() {
+        super();
+        this.currentStudy = null;
+        this.currentSession = null;
+        this.activeQuestions = new Map(); // questionId -> question data
+        this.questionResponses = new Map(); // questionId -> response data
+        this.transcriptBuffer = []; // Recent transcript segments for analysis
+        this.lastAnalysisTime = 0;
+        this.analysisInterval = 1000; // Minimum 1 second between analyses to prevent spam
+        this.isLiveAnalysisActive = false;
+        this.currentQuestionBeingAsked = null; // Track which question is currently being asked
+        this.currentAnswerBeingGiven = ''; // Track the current answer being provided
+        this.pendingAnalysis = false; // Track if analysis is already scheduled
+        
+        // Follow-up question management
+        this.bestFollowUpQuestions = []; // 2 best current follow-up questions from AI
+        this.displayedFollowUpQuestions = []; // Questions currently shown to user with timestamps
+        this.followUpQuestionTimeout = 10000; // 10 seconds timeout for expiring questions
+        this.followUpQuestionMetrics = {
+            totalSuggested: 0,
+            totalAsked: 0,
+            responses: []
+        };
+        this.lastFollowUpUpdateTime = 0; // Track when follow-ups were last updated
+        this.followUpUpdateInterval = 8000; // Minimum 8 seconds between follow-up updates
+        this._listenService = null; // Lazy-loaded to avoid circular dependency
+        
+        // Interviewer-driven question activation
+        this.lastInterviewerQuestionAt = 0; // Timestamp when interviewer last asked a question
+        this.questionEmbeddings = new Map(); // questionId -> Float32Array embeddings
+        this.participantTurnBuffer = ''; // Buffer for debounced participant scoring
+        this.lastParticipantScoringAt = 0; // Timestamp of last scoring operation
+        
+        // Metrics and telemetry
+        this.metrics = {
+            interviewerTurns: 0,
+            questionActivations: 0,
+            participantTurns: 0,
+            monotonicBlocks: 0,
+            followUpsShown: 0
+        };
+        
+        console.log('[ResearchService] Service initialized with interviewer-driven detection');
+    }
+
+    // Lazy load listen service to avoid circular dependency
+    _getListenService() {
+        if (!this._listenService) {
+            this._listenService = require('../listen/listenService');
+        }
+        return this._listenService;
+    }
+
+    // ==================== STUDY MANAGEMENT ====================
+    
+    async createStudy(studyData) {
+        console.log('[ResearchService] createStudy called with data:', studyData);
+        const studyId = crypto.randomUUID();
+        const currentUser = authService.getCurrentUser();
+        const uid = currentUser ? currentUser.uid : 'default_user';
+        
+        const study = {
+            id: studyId,
+            uid: uid,
+            title: studyData.title,
+            description: studyData.description || '',
+            research_type: studyData.research_type || 'user_interview',
+            methodology: studyData.methodology || 'semi_structured',
+            participant_profile: studyData.participant_profile || '',
+            goals: studyData.goals || '',
+            context: studyData.context || '',
+            status: 'draft',
+            created_at: Math.floor(Date.now() / 1000),
+            updated_at: Math.floor(Date.now() / 1000)
+        };
+        
+        console.log('[ResearchService] About to create study:', study);
+        await researchStudyRepository.create(study);
+        console.log(`[ResearchService] Created study: ${studyId}`);
+        return study;
+    }
+
+    async updateStudy(studyId, updateData) {
+        const updated = await researchStudyRepository.update(studyId, {
+            ...updateData,
+            updated_at: Math.floor(Date.now() / 1000)
+        });
+        
+        if (this.currentStudy && this.currentStudy.id === studyId) {
+            this.currentStudy = { ...this.currentStudy, ...updateData };
+        }
+        
+        return updated;
+    }
+
+    async getStudy(studyId) {
+        const currentUser = authService.getCurrentUser();
+        const uid = currentUser ? currentUser.uid : 'default_user';
+        return await researchStudyRepository.getById(studyId, uid);
+    }
+
+    async getAllStudies() {
+        const currentUser = authService.getCurrentUser();
+        const uid = currentUser ? currentUser.uid : 'default_user';
+        return await researchStudyRepository.getAll(uid);
+    }
+
+    async deleteStudy(studyId) {
+        const currentUser = authService.getCurrentUser();
+        const uid = currentUser ? currentUser.uid : 'default_user';
+        
+        // Delete related questions and responses
+        await researchQuestionRepository.deleteByStudyId(studyId);
+        await questionResponseRepository.deleteByStudyId(studyId);
+        await researchStudyRepository.delete(studyId, uid);
+        
+        if (this.currentStudy && this.currentStudy.id === studyId) {
+            this.currentStudy = null;
+            this.activeQuestions.clear();
+        }
+        
+        console.log(`[ResearchService] Deleted study: ${studyId}`);
+    }
+
+    // ==================== QUESTION MANAGEMENT ====================
+    
+    async addQuestion(studyId, questionData) {
+        const questionId = crypto.randomUUID();
+        const question = {
+            id: questionId,
+            study_id: studyId,
+            question_text: questionData.question_text,
+            question_type: questionData.question_type || 'open',
+            category: questionData.category || 'behavior',
+            priority: questionData.priority || 'medium',
+            order_index: questionData.order_index || 0,
+            is_required: questionData.is_required ? 1 : 0,
+            follow_up_hints: JSON.stringify(questionData.follow_up_hints || []),
+            created_at: Math.floor(Date.now() / 1000)
+        };
+        
+        await researchQuestionRepository.create(question);
+        console.log(`[ResearchService] Added question to study ${studyId}: ${questionId}`);
+        return question;
+    }
+
+    async updateQuestion(questionId, updateData) {
+        if (updateData.follow_up_hints) {
+            updateData.follow_up_hints = JSON.stringify(updateData.follow_up_hints);
+        }
+        return await researchQuestionRepository.update(questionId, updateData);
+    }
+
+    async getStudyQuestions(studyId) {
+        const questions = await researchQuestionRepository.getByStudyId(studyId);
+        return questions.map(q => ({
+            ...q,
+            follow_up_hints: q.follow_up_hints ? JSON.parse(q.follow_up_hints) : []
+        }));
+    }
+
+    async deleteQuestion(questionId) {
+        await questionResponseRepository.deleteByQuestionId(questionId);
+        await researchQuestionRepository.delete(questionId);
+        
+        if (this.activeQuestions.has(questionId)) {
+            this.activeQuestions.delete(questionId);
+            this.questionResponses.delete(questionId);
+        }
+    }
+
+    // ==================== RESEARCH SESSION MANAGEMENT ====================
+    
+    async startResearchSession(studyId, participantData = {}) {
+        // Get or create a regular session
+        const sessionId = await sessionRepository.getOrCreateActive('research');
+        await sessionRepository.updateType(sessionId, 'research');
+        
+        // Load study and questions
+        this.currentStudy = await this.getStudy(studyId);
+        if (!this.currentStudy) {
+            throw new Error(`Study not found: ${studyId}`);
+        }
+        
+        const questions = await this.getStudyQuestions(studyId);
+        this.activeQuestions.clear();
+        this.questionResponses.clear();
+        
+        questions.forEach(question => {
+            this.activeQuestions.set(question.id, question);
+            this.questionResponses.set(question.id, {
+                id: crypto.randomUUID(),
+                session_id: sessionId,
+                question_id: question.id,
+                status: 'not_asked',
+                completeness_score: 0.0,
+                ai_confidence: 0.0,
+                follow_up_needed: 0,
+                // New fields for interviewer-driven detection
+                summarized_answer: '',
+                max_completeness: 0.0,
+                needs_clarification_flag: 0,
+                last_model_score: 0.0,
+                created_at: tsSec(),
+                updated_at: tsSec()
+            });
+        });
+        
+        // Create research session record
+        this.currentSession = {
+            session_id: sessionId,
+            study_id: studyId,
+            participant_id: participantData.participant_id || `participant_${Date.now()}`,
+            participant_notes: participantData.participant_notes || '',
+            session_notes: '',
+            research_mode: 'live',
+            questions_asked: 0,
+            questions_completed: 0,
+            session_quality_score: 0.0,
+            created_at: Math.floor(Date.now() / 1000)
+        };
+        
+        await researchSessionRepository.create(this.currentSession);
+        
+        // Start live analysis
+        this.isLiveAnalysisActive = true;
+        this.transcriptBuffer = [];
+        this.lastAnalysisTime = Date.now();
+        this.pendingAnalysis = false;
+        
+        // Reset follow-up question state
+        this.bestFollowUpQuestions = [];
+        this.displayedFollowUpQuestions = [];
+        this.lastFollowUpUpdateTime = 0;
+        this.followUpQuestionMetrics = {
+            totalSuggested: 0,
+            totalAsked: 0,
+            responses: []
+        };
+        
+        // Start listen service to capture audio for analysis
+        try {
+            console.log('[ResearchService] Starting listen service for audio capture...');
+            const listenService = this._getListenService();
+            await listenService.handleListenRequest('Listen');
+            console.log('[ResearchService] Listen service started successfully');
+            
+            // Ensure listen window is visible for microphone capture
+            console.log('[ResearchService] Making listen window visible for microphone capture...');
+            internalBridge.emit('window:requestVisibility', { name: 'listen', visible: true });
+            
+            // Wait a moment for window to be ready, then start microphone capture
+            setTimeout(() => {
+                console.log('[ResearchService] Triggering microphone capture start...');
+                listenService.sendToRenderer('change-listen-capture-state', { status: "start" });
+            }, 1000);
+            
+            // Also start audio capture
+            console.log('[ResearchService] Starting macOS audio capture...');
+            await listenService.startMacOSAudioCapture();
+            console.log('[ResearchService] Audio capture started successfully');
+        } catch (error) {
+            console.error('[ResearchService] Failed to start listen service or audio capture:', error);
+            // Don't fail the research session if listen service fails
+        }
+        
+        console.log(`[ResearchService] Started research session for study: ${studyId}`);
+        
+        // Emit initial status with first question ready
+        this.emit('session-started', { studyId, sessionId, questionsCount: questions.length });
+        
+        // Emit initial analysis update to show first question
+        setTimeout(() => {
+            this.emit('analysis-update', {
+                status: this.getSessionStatus(),
+                suggestions: [],
+                currentQuestion: null,
+                nextQuestion: this.getNextQuestionToAsk()
+            });
+        }, 100); // Small delay to ensure UI is ready
+        
+        return {
+            sessionId,
+            study: this.currentStudy,
+            questions: Array.from(this.activeQuestions.values()),
+            status: this.getSessionStatus()
+        };
+    }
+
+    async endResearchSession() {
+        if (!this.currentSession) {
+            return;
+        }
+        
+        this.isLiveAnalysisActive = false;
+        this.pendingAnalysis = false;
+        
+        // Stop listen service and audio capture
+        try {
+            console.log('[ResearchService] Stopping audio capture and listen service...');
+            const listenService = this._getListenService();
+            await listenService.stopMacOSAudioCapture();
+            await listenService.handleListenRequest('Stop');
+            
+            // Hide listen window
+            console.log('[ResearchService] Hiding listen window...');
+            internalBridge.emit('window:requestVisibility', { name: 'listen', visible: false });
+            
+            console.log('[ResearchService] Audio capture and listen service stopped successfully');
+        } catch (error) {
+            console.error('[ResearchService] Failed to stop listen service or audio capture:', error);
+        }
+        
+        // Save all responses
+        for (const response of this.questionResponses.values()) {
+            if (response.status !== 'not_asked') {
+                await questionResponseRepository.createOrUpdate(response);
+            }
+        }
+        
+        // Update session summary
+        const status = this.getSessionStatus();
+        await researchSessionRepository.update(this.currentSession.session_id, {
+            questions_asked: status.questionsAsked,
+            questions_completed: status.questionsCompleted,
+            session_quality_score: this.calculateSessionQuality(),
+            research_mode: 'completed'
+        });
+        
+        // End the regular session
+        await sessionRepository.end(this.currentSession.session_id);
+        
+        console.log(`[ResearchService] Ended research session: ${this.currentSession.session_id}`);
+        
+        // Dump session metrics
+        this._dumpSessionMetrics();
+        
+        this.emit('session-ended', this.getSessionStatus());
+        
+        this.currentSession = null;
+        this.currentStudy = null;
+        this.activeQuestions.clear();
+        this.questionResponses.clear();
+    }
+
+    // ==================== LIVE ANALYSIS ====================
+    
+    async processTranscriptSegment(speaker, text, timestamp) {
+        if (!this.isLiveAnalysisActive || !this.currentStudy) {
+            console.log('[ResearchService] Skipping transcript - analysis not active or no study');
+            return;
+        }
+        
+        console.log(`[ResearchService] Processing transcript: ${speaker} - ${text.substring(0, 50)}...`);
+        
+        // Add to transcript buffer
+        this.transcriptBuffer.push({
+            speaker,
+            text,
+            timestamp,
+            processed: false
+        });
+        
+        // Keep buffer manageable (last 50 segments)
+        if (this.transcriptBuffer.length > 50) {
+            this.transcriptBuffer.shift();
+        }
+        
+        console.log(`[ResearchService] Transcript buffer size: ${this.transcriptBuffer.length}`);
+        
+        // Trigger analysis immediately for real-time response, with throttling to prevent spam
+        const now = Date.now();
+        const timeSinceLastAnalysis = now - this.lastAnalysisTime;
+        console.log(`[ResearchService] Time since last analysis: ${timeSinceLastAnalysis}ms (minimum interval: ${this.analysisInterval}ms)`);
+        
+        // Check if this is meaningful text worth analyzing immediately
+        const isMeaningfulText = text.trim().length > 2 && !text.match(/^(um|uh|hmm|ah|er)$/i);
+        
+        if (timeSinceLastAnalysis >= this.analysisInterval || (isMeaningfulText && !this.pendingAnalysis)) {
+            if (timeSinceLastAnalysis >= this.analysisInterval) {
+                console.log('[ResearchService] Triggering immediate AI analysis...');
+                await this.analyzeRecentTranscript();
+                this.lastAnalysisTime = now;
+            } else if (!this.pendingAnalysis) {
+                // Schedule delayed analysis to respect minimum interval
+                console.log('[ResearchService] Scheduling delayed AI analysis...');
+                this.pendingAnalysis = true;
+                const delay = this.analysisInterval - timeSinceLastAnalysis;
+                setTimeout(async () => {
+                    if (this.isLiveAnalysisActive && this.pendingAnalysis) {
+                        console.log('[ResearchService] Triggering delayed AI analysis...');
+                        await this.analyzeRecentTranscript();
+                        this.lastAnalysisTime = Date.now();
+                        this.pendingAnalysis = false;
+                    }
+                }, delay);
+            }
+        } else {
+            console.log('[ResearchService] Skipping analysis - too soon, not meaningful text, or analysis already pending');
+        }
+    }
+
+    async analyzeRecentTranscript() {
+        const unprocessedSegments = this.transcriptBuffer.filter(seg => !seg.processed);
+        console.log(`[ResearchService] Analyzing ${unprocessedSegments.length} unprocessed transcript segments`);
+        
+        if (unprocessedSegments.length === 0) {
+            console.log('[ResearchService] No unprocessed segments to analyze');
+            return;
+        }
+        
+        try {
+            // Get recent transcript text
+            const recentText = unprocessedSegments
+                .map(seg => `${seg.speaker}: ${seg.text}`)
+                .join('\n');
+            
+            console.log(`[ResearchService] Transcript to analyze:\n${recentText}`);
+            
+            // Prepare questions for analysis
+            const activeQuestionsList = Array.from(this.activeQuestions.values());
+            const questionContext = activeQuestionsList.map(q => ({
+                id: q.id,
+                text: q.question_text,
+                category: q.category,
+                status: this.questionResponses.get(q.id)?.status || 'not_asked'
+            }));
+            
+            console.log(`[ResearchService] Analyzing against ${questionContext.length} questions`);
+            questionContext.forEach(q => {
+                console.log(`[ResearchService] Question ${q.id.substring(0, 8)}: "${q.text.substring(0, 60)}..." (status: ${q.status})`);
+            });
+            
+            // AI analysis
+            const analysis = await this.performQuestionAnalysis(recentText, questionContext);
+            console.log('[ResearchService] AI analysis completed:', analysis);
+            
+            // Log which questions the AI thinks are being addressed
+            if (analysis.question_updates) {
+                analysis.question_updates.forEach(update => {
+                    const question = this.activeQuestions.get(update.questionId);
+                    console.log(`[ResearchService] AI update for question ${update.questionId.substring(0, 8)}: "${question?.question_text?.substring(0, 60)}..." -> status: ${update.status}, score: ${update.completeness_score}`);
+                });
+            }
+            
+            // Update question responses based on analysis
+            await this.updateQuestionResponses(analysis, unprocessedSegments);
+            
+            // Update current question and answer tracking
+            await this.updateCurrentQuestionTracking(analysis, unprocessedSegments);
+            
+            // Mark segments as processed
+            unprocessedSegments.forEach(seg => seg.processed = true);
+            
+            // Update follow-up questions with intelligent management
+            this.updateFollowUpQuestions(analysis.suggestions || []);
+            
+            // Emit updates
+            this.emit('analysis-update', {
+                status: this.getSessionStatus(),
+                suggestions: this.getDisplayedFollowUpQuestions(),
+                currentQuestion: this.getCurrentQuestionContext(),
+                nextQuestion: this.getNextQuestionToAsk(),
+                followUpMetrics: this.followUpQuestionMetrics
+            });
+            
+            console.log('[ResearchService] Analysis update emitted to UI');
+            
+        } catch (error) {
+            console.error('[ResearchService] Analysis error:', error);
+        }
+    }
+
+    async performQuestionAnalysis(transcriptText, questions) {
+        const modelInfo = await modelStateService.getCurrentModelInfo('llm');
+        if (!modelInfo || !modelInfo.apiKey) {
+            throw new Error('AI model not configured for research analysis');
+        }
+        
+        const systemPrompt = this.buildResearchAnalysisPrompt(questions);
+        
+        const messages = [
+            { role: 'system', content: systemPrompt },
+            { 
+                role: 'user', 
+                content: `Analyze this recent transcript segment and provide question tracking updates:
+
+TRANSCRIPT:
+${transcriptText}
+
+Please respond with a JSON object containing:
+1. "question_updates": Array of {questionId, status, completeness_score, key_insights, follow_up_needed}
+2. "suggestions": Array of 1-2 specific follow-up questions that reference what the participant just said
+3. "overall_analysis": Brief summary of conversation progress
+
+Focus on generating contextual follow-ups that directly build on the participant's specific responses.`
+            }
+        ];
+        
+        const llm = createLLM(modelInfo.provider, {
+            apiKey: modelInfo.apiKey,
+            model: modelInfo.model,
+            temperature: 0.3,
+            maxTokens: 1500
+        });
+        
+        const completion = await llm.chat(messages);
+        
+        try {
+            // Robust JSON extraction - handle markdown fences, prose, etc.
+            return this.extractJson(completion.content);
+        } catch (parseError) {
+            console.error('[ResearchService] Failed to parse AI response:', parseError.message);
+            console.error('[ResearchService] Raw AI response:', completion.content);
+            return { question_updates: [], suggestions: [], overall_analysis: '' };
+        }
+    }
+
+    buildResearchAnalysisPrompt(questions) {
+        return `You are an expert UX research assistant analyzing live interview transcripts. Your goal is to track which research questions are being answered and suggest intelligent follow-ups.
+
+RESEARCH CONTEXT:
+Study: ${this.currentStudy.title}
+Goals: ${this.currentStudy.goals}
+Methodology: ${this.currentStudy.methodology}
+
+QUESTIONS TO TRACK:
+${questions.map(q => `- ${q.id}: [${q.category}] ${q.text} (Current status: ${q.status})`).join('\n')}
+
+CRITICAL ID RULE: For each question above, I show id=(uuid). In your question_updates array, you MUST use that exact UUID string in the questionId field. Copy/paste exactly from the list above - do not shorten, truncate, or renumber. Any questionId that doesn't exactly match will be ignored.
+
+ANALYSIS GUIDELINES:
+1. Question Status Mapping:
+   - "not_asked": Question hasn't been addressed yet
+   - "partial": Question only briefly touched on or response was very vague (use sparingly)
+   - "complete": Question adequately answered - participant provided a response that addresses the core question (be generous with this)
+   - "needs_clarification": Answer given but unclear or contradictory
+
+2. Completeness Scoring (0.0-1.0):
+   - Score conservatively - require substantial content that clearly addresses the question
+   - 0.3-0.5: Question touched on but response is vague or incomplete
+   - 0.6-0.8: Question adequately answered with relevant details
+   - 0.9+: Comprehensive answer with examples, context, or multiple aspects covered
+   - Only mark as "complete" when the participant has provided sufficient detail
+
+3. Follow-up Suggestions:
+   - ONLY suggest follow-ups when the participant's response is incomplete, vague, or needs clarification
+   - Do NOT suggest follow-ups if the conversation is flowing naturally or if questions are being adequately answered
+   - When you do suggest, make them SPECIFIC and reference exact details the participant mentioned
+   - Ask for concrete examples, specific situations, or deeper exploration of pain points they raised
+   - Use phrases like "You mentioned X..." or "When you said Y..." to show you're building on their words
+   - Focus on actionable details: "how does", "what happens when", "can you describe a specific time"
+   - Avoid generic suggestions like "tell me more" or "anything else" - be precise about what you need to know
+
+4. Key Insights:
+   - Extract actionable insights about user behavior, pain points, motivations
+   - Note emotional responses and non-verbal cues mentioned
+   - Identify patterns or themes emerging
+
+RESPONSE FORMAT: Valid JSON only, no additional text.`;
+    }
+
+    async updateQuestionResponses(analysis, transcriptSegments) {
+        if (!analysis.question_updates) return;
+        
+        console.log(`[ResearchService] Applying ${analysis.question_updates.length} question updates with monotonic enforcement`);
+        
+        for (const update of analysis.question_updates) {
+            const questionId = update.questionId;
+            
+            // P0 Fix: Validate questionId exists in our active questions
+            if (!this.activeQuestions.has(questionId)) {
+                console.warn(`[ResearchService] AI returned invalid questionId: "${questionId}" - skipping update`);
+                continue;
+            }
+            
+            // Use monotonic update instead of direct assignment
+            this._applyMonotonicUpdate(questionId, {
+                new_completeness: update.completeness_score,
+                needs_clarification: update.follow_up_needed || update.status === 'needs_clarification',
+                delta_insights: update.key_insights || []
+            });
+            
+            // Update additional fields (non-monotonic)
+            const response = this.questionResponses.get(questionId);
+            if (response) {
+                response.ai_confidence = update.ai_confidence || 0.7;
+                
+                // Extract relevant transcript text
+                if (transcriptSegments.length > 0) {
+                    response.transcript_segment_start = transcriptSegments[0].timestamp;
+                    response.transcript_segment_end = transcriptSegments[transcriptSegments.length - 1].timestamp;
+                    response.response_text = transcriptSegments.map(s => s.text).join(' ');
+                }
+                
+                this.questionResponses.set(questionId, response);
+            }
+        }
+    }
+
+    async updateCurrentQuestionTracking(analysis, transcriptSegments) {
+        console.log(`[ResearchService] === TRACKING DEBUG ===`);
+        console.log(`[ResearchService] Current question before update: ${this.currentQuestionBeingAsked?.substring(0, 8)}...`);
+        console.log(`[ResearchService] Analysis question_updates:`, analysis.question_updates);
+        
+        // P0 Fix: Normalize speaker labels
+        const INTERVIEWER_SPEAKERS = new Set(['Me', 'Researcher', 'Interviewer', 'Host', 'Agent']);
+        const interviewerSegments = transcriptSegments.filter(seg => 
+            INTERVIEWER_SPEAKERS.has(seg.speaker)
+        );
+        
+        console.log(`[ResearchService] Found ${interviewerSegments.length} interviewer segments`);
+        
+        // Method 1: Interviewer-driven question activation
+        if (interviewerSegments.length > 0) {
+            this.metrics.interviewerTurns++;
+            
+            // Collapse interviewer segments into single turn
+            const interviewerTurnText = interviewerSegments.map(seg => seg.text).join(' ');
+            
+            // Only process if this looks like a question
+            if (this.hasQuestionPattern(interviewerTurnText)) {
+                console.log(`[ResearchService] Processing interviewer question turn: "${interviewerTurnText.substring(0, 100)}..."`);
+                
+                // Classify turn to study question
+                const classification = await this.classifyInterviewerTurnToQuestion(interviewerTurnText);
+                
+                if (classification.questionId) {
+                    // Activate the matched question
+                    this._activateQuestion(
+                        classification.questionId, 
+                        Date.now(), 
+                        interviewerTurnText
+                    );
+                } else {
+                    console.log(`[ResearchService] Question pattern detected but no study question match (off-script)`);
+                }
+            } else {
+                console.log(`[ResearchService] Interviewer speaking but no question pattern: "${interviewerTurnText.substring(0, 50)}..."`);
+            }
+        }
+        
+        // Method 2: Process AI updates for currently active question only (no auto-switching)
+        console.log(`[ResearchService] Processing AI updates for active question only...`);
+        if (analysis.question_updates && this.currentQuestionBeingAsked) {
+            console.log(`[ResearchService] Found ${analysis.question_updates.length} question updates`);
+            
+            // Only process updates for the currently active question
+            const activeQuestionUpdates = analysis.question_updates.filter(update => 
+                update.questionId === this.currentQuestionBeingAsked
+            );
+            
+            if (activeQuestionUpdates.length > 0) {
+                const update = activeQuestionUpdates[0];
+                console.log(`[ResearchService] Processing update for active question ${update.questionId.substring(0, 8)}: score=${update.completeness_score}, status=${update.status}`);
+                
+                // Apply monotonic update instead of direct assignment
+                this._applyMonotonicUpdate(update.questionId, {
+                    new_completeness: update.completeness_score,
+                    needs_clarification: update.follow_up_needed || update.status === 'needs_clarification',
+                    delta_insights: update.key_insights || []
+                });
+            }
+            
+            // Log but ignore updates for non-active questions
+            const ignoredUpdates = analysis.question_updates.filter(update => 
+                update.questionId !== this.currentQuestionBeingAsked
+            );
+            if (ignoredUpdates.length > 0) {
+                console.log(`[ResearchService] Ignoring ${ignoredUpdates.length} AI-suggested question switches; interviewer not detected`);
+            }
+        } else if (analysis.question_updates && !this.currentQuestionBeingAsked) {
+            console.log(`[ResearchService] Ignoring AI updates - no active interviewer question`);
+        }
+        
+        // Method 3: Handle participant responses for active question only
+        const participantText = transcriptSegments
+            .filter(seg => !INTERVIEWER_SPEAKERS.has(seg.speaker))
+            .map(seg => seg.text)
+            .join(' ');
+            
+        if (participantText.trim()) {
+            this.metrics.participantTurns++;
+            
+            if (this.currentQuestionBeingAsked) {
+                // Accumulate answer for active question
+                this.currentAnswerBeingGiven = concatClean(this.currentAnswerBeingGiven, participantText);
+                
+                // Keep answer reasonably sized (last 500 characters)
+                if (this.currentAnswerBeingGiven.length > 500) {
+                    this.currentAnswerBeingGiven = '...' + this.currentAnswerBeingGiven.slice(-500);
+                }
+                
+                console.log(`[ResearchService] Participant response added to active question ${this.currentQuestionBeingAsked.substring(0, 8)}: "${participantText.substring(0, 100)}..."`);
+                
+                // TODO: Add debounced incremental scoring here later
+            } else {
+                // No active question - treat as pre/post talk
+                console.log(`[ResearchService] Participant pre/post talk (no active question): "${participantText.substring(0, 50)}..."`);
+            }
+        }
+        
+        // Log current state for debugging
+        if (this.currentQuestionBeingAsked) {
+            const question = this.activeQuestions.get(this.currentQuestionBeingAsked);
+            console.log(`[ResearchService] Current question: "${question?.question_text?.substring(0, 50)}..."`);
+            console.log(`[ResearchService] Current answer: "${this.currentAnswerBeingGiven?.substring(0, 100)}..."`);
+        } else {
+            console.log(`[ResearchService] No current question identified`);
+        }
+    }
+
+    findClosestStudyQuestion(interviewerText) {
+        if (!interviewerText || !this.activeQuestions || this.activeQuestions.size === 0) {
+            return null;
+        }
+
+        const interviewerLower = interviewerText.toLowerCase();
+        let bestMatch = null;
+        let bestScore = 0;
+        const threshold = 0.15; // Minimum similarity threshold (lowered for improved algorithm)
+
+        for (const [questionId, question] of this.activeQuestions.entries()) {
+            const questionText = question.question_text.toLowerCase();
+            
+            // Calculate similarity score using word overlap
+            const similarity = this.calculateSimilarity(interviewerLower, questionText);
+            
+            console.log(`[ResearchService] Similarity check: "${questionText.substring(0, 30)}..." = ${Math.round(similarity * 100)}%`);
+            
+            if (similarity > bestScore && similarity >= threshold) {
+                bestScore = similarity;
+                bestMatch = question;
+            }
+        }
+
+        if (bestMatch) {
+            console.log(`[ResearchService] Best match found with ${Math.round(bestScore * 100)}% similarity: ${bestMatch.question_text?.substring(0, 50)}...`);
+        }
+
+        return bestMatch;
+    }
+
+    calculateSimilarity(text1, text2) {
+        // Improved similarity calculation that handles paraphrased questions better
+        const normalize = (text) => text.toLowerCase()
+            .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
+            .replace(/\s+/g, ' ') // Normalize multiple spaces
+            .trim();
+        
+        const normalized1 = normalize(text1);
+        const normalized2 = normalize(text2);
+        
+        // Split into words, keep words with length > 1 (include "do", "is", etc.)
+        const words1 = normalized1.split(' ').filter(word => word.length > 1);
+        const words2 = normalized2.split(' ').filter(word => word.length > 1);
+        
+        if (words1.length === 0 || words2.length === 0) return 0;
+        
+        // Simple stemming - remove common endings
+        const stemWord = (word) => {
+            return word
+                .replace(/(?:ing|ed|er|est|ly|tion|sion)$/, '') // Remove common suffixes
+                .replace(/(?:s)$/, ''); // Remove plural 's'
+        };
+        
+        const stemmed1 = words1.map(stemWord);
+        const stemmed2 = words2.map(stemWord);
+        
+        // Calculate multiple similarity metrics
+        
+        // 1. Exact word matches (higher weight)
+        const exactMatches = words1.filter(word => words2.includes(word)).length;
+        
+        // 2. Stemmed word matches (medium weight)
+        const stemmedMatches = stemmed1.filter(stem => stemmed2.includes(stem)).length;
+        
+        // 3. Partial word matches for longer words (lower weight)
+        let partialMatches = 0;
+        for (const word1 of words1) {
+            if (word1.length >= 4) { // Only for longer words
+                for (const word2 of words2) {
+                    if (word2.length >= 4 && (word1.includes(word2) || word2.includes(word1))) {
+                        partialMatches += 0.5;
+                        break;
+                    }
+                }
+            }
+        }
+        
+        // 4. Key question words bonus (question starters, important words)
+        const questionWords = ['what', 'how', 'why', 'when', 'where', 'who', 'which', 
+                              'can', 'could', 'would', 'should', 'do', 'does', 'did',
+                              'describe', 'tell', 'explain', 'think', 'feel', 'experience'];
+        
+        let questionWordMatches = 0;
+        for (const qWord of questionWords) {
+            if (words1.includes(qWord) && words2.includes(qWord)) {
+                questionWordMatches += 1;
+            }
+        }
+        
+        // Calculate weighted score
+        const totalPossibleMatches = Math.max(words1.length, words2.length);
+        const weightedScore = (
+            (exactMatches * 1.0) +           // Exact matches: full weight
+            (stemmedMatches * 0.8) +         // Stemmed matches: 80% weight  
+            (partialMatches * 0.6) +         // Partial matches: 60% weight
+            (questionWordMatches * 1.2)      // Question words: 120% weight (bonus)
+        ) / totalPossibleMatches;
+        
+        // Cap at 1.0 and apply minimum threshold
+        return Math.min(1.0, weightedScore);
+    }
+
+    hasQuestionPattern(text) {
+        if (!text || text.trim().length < 3) return false;
+        
+        const normalizedText = text.toLowerCase().trim();
+        
+        // Check for question mark
+        if (text.includes('?')) return true;
+        
+        // Check for question words at start
+        const questionStarters = ['what', 'how', 'why', 'when', 'where', 'who', 'which', 'can', 'could', 'would', 'should', 'do', 'does', 'did', 'is', 'are', 'will'];
+        const firstWord = normalizedText.split(/\s+/)[0];
+        if (questionStarters.includes(firstWord)) return true;
+        
+        // Check for common interview phrases
+        const interviewPhrases = ['tell me about', 'describe', 'explain', 'walk me through', 'share', 'imagine'];
+        if (interviewPhrases.some(phrase => normalizedText.includes(phrase))) return true;
+        
+        return false;
+    }
+
+    filterHighQualityFollowUps(suggestions) {
+        if (!suggestions || suggestions.length === 0) return [];
+        
+        // Check if follow-ups are actually needed based on conversation state
+        if (!this.shouldSuggestFollowUps()) {
+            console.log(`[ResearchService] Follow-ups not needed - conversation is flowing well`);
+            return [];
+        }
+        
+        // Filter individual suggestions for quality
+        const highQualitySuggestions = suggestions.filter(suggestion => {
+            return this.isHighQualityFollowUp(suggestion);
+        });
+        
+        console.log(`[ResearchService] Quality filtered suggestions from ${suggestions.length} to ${highQualitySuggestions.length}`);
+        return highQualitySuggestions;
+    }
+
+    shouldSuggestFollowUps() {
+        // Don't suggest follow-ups if we have no active question context
+        if (!this.currentQuestionBeingAsked) {
+            return false;
+        }
+        
+        // Check the completeness of current and recent questions
+        const currentResponse = this.questionResponses.get(this.currentQuestionBeingAsked);
+        if (!currentResponse) return false;
+        
+        // Only suggest if the current question needs more detail
+        const needsMoreDetail = currentResponse.completeness_score < 0.7 || 
+                               currentResponse.status === 'partial' ||
+                               currentResponse.status === 'needs_clarification';
+        
+        if (!needsMoreDetail) {
+            console.log(`[ResearchService] Current question sufficiently complete (score: ${currentResponse.completeness_score}, status: ${currentResponse.status})`);
+            return false;
+        }
+        
+        // Don't suggest if participant just started answering (give them time)
+        if (this.currentAnswerBeingGiven && this.currentAnswerBeingGiven.length < 50) {
+            console.log(`[ResearchService] Participant just started answering, waiting for more content`);
+            return false;
+        }
+        
+        // Don't suggest if we're already showing recent, relevant follow-ups
+        if (this.displayedFollowUpQuestions.length > 0) {
+            const mostRecentFollowUp = Math.max(...this.displayedFollowUpQuestions.map(q => q.displayedAt));
+            const timeSinceLastFollowUp = Date.now() - mostRecentFollowUp;
+            
+            if (timeSinceLastFollowUp < 15000) { // Less than 15 seconds
+                console.log(`[ResearchService] Already showing recent follow-ups, waiting ${15000 - timeSinceLastFollowUp}ms`);
+                return false;
+            }
+        }
+        
+        return true;
+    }
+
+    isHighQualityFollowUp(suggestion) {
+        if (!suggestion || typeof suggestion !== 'string' || suggestion.length < 20) {
+            return false;
+        }
+        
+        const lowerSuggestion = suggestion.toLowerCase();
+        
+        // Filter out generic or low-value suggestions
+        const lowQualityPatterns = [
+            'can you tell me more',
+            'could you elaborate',
+            'anything else',
+            'is there anything',
+            'what do you think',
+            'how do you feel about that'
+        ];
+        
+        const hasLowQualityPattern = lowQualityPatterns.some(pattern => 
+            lowerSuggestion.includes(pattern)
+        );
+        
+        if (hasLowQualityPattern) {
+            console.log(`[ResearchService] Filtered out low-quality suggestion: "${suggestion.substring(0, 50)}..."`);
+            return false;
+        }
+        
+        // Require suggestions to be specific and reference participant's actual words
+        const hasSpecificReference = /you mentioned|when you said|you described|you talked about/i.test(suggestion);
+        if (!hasSpecificReference) {
+            console.log(`[ResearchService] Filtered out non-specific suggestion: "${suggestion.substring(0, 50)}..."`);
+            return false;
+        }
+        
+        // Must be asking for concrete details, examples, or clarification
+        const hasGoodIntent = /how does|what happens|can you describe|give an example|specific situation|what would/i.test(suggestion);
+        if (!hasGoodIntent) {
+            console.log(`[ResearchService] Filtered out vague suggestion: "${suggestion.substring(0, 50)}..."`);
+            return false;
+        }
+        
+        return true;
+    }
+
+    // ==================== MONOTONIC COMPLETENESS ENFORCEMENT ====================
+    
+    _applyMonotonicUpdate(questionId, {new_completeness, needs_clarification, delta_insights}) {
+        const r = this.questionResponses.get(questionId);
+        if (!r) {
+            console.warn(`[ResearchService] Cannot apply monotonic update - questionId not found: ${questionId}`);
+            return;
+        }
+
+        const prev = r.completeness_score ?? 0;
+        
+        // Enforce monotonic completeness - never decrease
+        if (typeof new_completeness === 'number' && new_completeness > prev) {
+            r.completeness_score = new_completeness;
+            r.max_completeness = Math.max(r.max_completeness || 0, new_completeness);
+            console.log(`[ResearchService] Completeness increased: ${questionId.substring(0, 8)} ${prev} -> ${new_completeness}`);
+        } else if (typeof new_completeness === 'number' && new_completeness < prev) {
+            // Log monotonic block but don't decrease
+            this.metrics.monotonicBlocks++;
+            r.last_model_score = new_completeness;
+            console.log(`[ResearchService] Monotonic block: ${questionId.substring(0, 8)} tried to decrease ${prev} -> ${new_completeness}`);
+        } else {
+            // Same score or invalid - just record what model suggested
+            r.last_model_score = new_completeness ?? prev;
+        }
+
+        // Handle clarification flag
+        if (needs_clarification) {
+            r.needs_clarification_flag = 1;
+            if (r.status !== 'complete') {
+                r.follow_up_needed = 1;
+            }
+            console.log(`[ResearchService] Clarification needed for question: ${questionId.substring(0, 8)}`);
+        }
+
+        // Status promotion rules based on completeness
+        if (r.status === 'not_asked' && r.completeness_score > 0) {
+            r.status = 'partial';
+        }
+        if (r.completeness_score >= 0.9) {
+            r.status = 'complete';
+        } else if (r.completeness_score >= 0.6 && r.status !== 'complete') {
+            r.status = 'partial';
+        }
+
+        // Merge delta insights
+        if (delta_insights?.length) {
+            const prevInsights = r.key_insights ? JSON.parse(r.key_insights) : [];
+            r.key_insights = JSON.stringify([...prevInsights, ...delta_insights]);
+        }
+
+        r.updated_at = tsSec();
+        this.questionResponses.set(questionId, r);
+        
+        console.log(`[ResearchService] Updated question ${questionId.substring(0, 8)}: score=${r.completeness_score}, status=${r.status}`);
+    }
+
+    // ==================== INTERVIEWER-DRIVEN QUESTION ACTIVATION ====================
+    
+    _activateQuestion(questionId, timestamp, turnText) {
+        if (!this.activeQuestions.has(questionId)) {
+            console.warn(`[ResearchService] Cannot activate invalid questionId: ${questionId}`);
+            return false;
+        }
+        
+        const question = this.activeQuestions.get(questionId);
+        const previousQuestionId = this.currentQuestionBeingAsked;
+        
+        this.currentQuestionBeingAsked = questionId;
+        this.currentAnswerBeingGiven = ''; // Reset answer for new question
+        this.lastInterviewerQuestionAt = timestamp;
+        this.metrics.questionActivations++;
+        
+        console.log(`[ResearchService] ‚úÖ Question activated: ${questionId.substring(0, 8)} - "${question.question_text?.substring(0, 60)}..."`);
+        console.log(`[ResearchService] Interviewer turn: "${turnText.substring(0, 100)}..."`);
+        
+        if (previousQuestionId && previousQuestionId !== questionId) {
+            console.log(`[ResearchService] Switched from question ${previousQuestionId.substring(0, 8)}`);
+        }
+        
+        return true;
+    }
+
+    async classifyInterviewerTurnToQuestion(turnText) {
+        try {
+            // Use simple similarity for now (can be enhanced with embeddings later)
+            const candidates = Array.from(this.activeQuestions.values()).map(q => ({
+                id: q.id,
+                text: q.question_text,
+                similarity: this.calculateSimilarity(turnText.toLowerCase(), q.question_text.toLowerCase())
+            })).sort((a, b) => b.similarity - a.similarity);
+
+            const best = candidates[0];
+            const threshold = 0.15; // Same as existing threshold
+            
+            if (best && best.similarity >= threshold) {
+                console.log(`[ResearchService] Interview turn classification: ${best.id.substring(0, 8)} (${Math.round(best.similarity * 100)}% confidence)`);
+                return {
+                    questionId: best.id,
+                    confidence: best.similarity,
+                    is_clarification: false // Simple version for now
+                };
+            }
+            
+            console.log(`[ResearchService] Interview turn classification: no match (best: ${Math.round((best?.similarity || 0) * 100)}%)`);
+            return {
+                questionId: null,
+                confidence: best?.similarity || 0,
+                is_clarification: false
+            };
+        } catch (error) {
+            console.error('[ResearchService] Error in interviewer turn classification:', error);
+            return { questionId: null, confidence: 0, is_clarification: false };
+        }
+    }
+
+    extractJson(content) {
+        // Handle common LLM response patterns
+        let cleaned = content.trim();
+        
+        // Remove markdown json fences
+        cleaned = cleaned.replace(/^```json\s*/i, '').replace(/\s*```$/, '');
+        
+        // Remove markdown code fences without language
+        cleaned = cleaned.replace(/^```\s*/, '').replace(/\s*```$/, '');
+        
+        // Find the first complete JSON object
+        const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
+        if (!jsonMatch) {
+            throw new Error('No JSON object found in response');
+        }
+        
+        let jsonStr = jsonMatch[0];
+        
+        // Try to clean up common issues
+        // Remove trailing commas before closing braces/brackets
+        jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
+        
+        return JSON.parse(jsonStr);
+    }
+
+    getCurrentQuestionContext() {
+        if (!this.currentQuestionBeingAsked) return null;
+        
+        const question = this.activeQuestions.get(this.currentQuestionBeingAsked);
+        const response = this.questionResponses.get(this.currentQuestionBeingAsked);
+        
+        return {
+            questionId: this.currentQuestionBeingAsked,
+            questionText: question?.question_text || '',
+            currentAnswer: this.currentAnswerBeingGiven || '',
+            status: response?.status || 'not_asked',
+            completeness_score: response?.completeness_score || 0.0
+        };
+    }
+
+    getNextQuestionToAsk() {
+        // Find the next logical question to ask (prioritize moving forward over completion)
+        const questionEntries = Array.from(this.questionResponses.entries());
+        console.log(`[ResearchService] Finding next question from ${questionEntries.length} questions`);
+        
+        // Priority 1: Next unasked question (ordered by order_index) - keep conversation moving forward
+        const unaskedQuestions = questionEntries
+            .filter(([id, response]) => response.status === 'not_asked')
+            .map(([id, response]) => {
+                const question = this.activeQuestions.get(id);
+                return { id, response, question, order_index: question?.order_index || 0 };
+            })
+            .sort((a, b) => a.order_index - b.order_index);
+            
+        console.log(`[ResearchService] Found ${unaskedQuestions.length} unasked questions`);
+        if (unaskedQuestions.length > 0) {
+            const nextQuestion = unaskedQuestions[0];
+            console.log(`[ResearchService] Next question: ${nextQuestion.question?.question_text?.substring(0, 50)}...`);
+            return {
+                questionId: nextQuestion.id,
+                questionText: nextQuestion.question?.question_text || '',
+                reason: 'next in sequence'
+            };
+        }
+        
+        // Priority 2: Partial questions that need completion (lower priority than new questions)
+        const partialQuestion = questionEntries.find(([id, response]) => 
+            response.status === 'partial' && id !== this.currentQuestionBeingAsked
+        );
+        if (partialQuestion) {
+            const question = this.activeQuestions.get(partialQuestion[0]);
+            console.log(`[ResearchService] Next question: needs completion - ${question?.question_text?.substring(0, 50)}...`);
+            return {
+                questionId: partialQuestion[0],
+                questionText: question?.question_text || '',
+                reason: 'needs completion'
+            };
+        }
+        
+        // Priority 3: Questions that need follow-up (only if no new questions available)
+        const needFollowUp = questionEntries.find(([id, response]) => 
+            response.follow_up_needed === 1 && id !== this.currentQuestionBeingAsked
+        );
+        if (needFollowUp) {
+            const question = this.activeQuestions.get(needFollowUp[0]);
+            console.log(`[ResearchService] Next question: follow-up needed - ${question?.question_text?.substring(0, 50)}...`);
+            return {
+                questionId: needFollowUp[0],
+                questionText: question?.question_text || '',
+                reason: 'follow-up needed'
+            };
+        }
+        
+        console.log(`[ResearchService] No next question found - all questions addressed`);
+        return null;
+    }
+
+
+
+    // ==================== FOLLOW-UP QUESTION MANAGEMENT ====================
+    
+    updateFollowUpQuestions(newSuggestions) {
+        const now = Date.now();
+        const timeSinceLastUpdate = now - this.lastFollowUpUpdateTime;
+        
+        // Quality filter: Only keep follow-ups that are actually needed
+        const filteredSuggestions = this.filterHighQualityFollowUps(newSuggestions);
+        
+        // Update best follow-up questions (take top 2)
+        this.bestFollowUpQuestions = filteredSuggestions.slice(0, 2);
+        this.followUpQuestionMetrics.totalSuggested += newSuggestions.length;
+        
+        console.log(`[ResearchService] Received ${newSuggestions.length} raw suggestions, filtered to ${filteredSuggestions.length} high-quality ones`);
+        console.log(`[ResearchService] Time since last follow-up update: ${timeSinceLastUpdate}ms`);
+        
+        // Always expire old questions first
+        this.expireOldFollowUpQuestions(now);
+        
+        // Only update displayed questions if enough time has passed AND suggestions are different
+        const shouldUpdateFollowUps = this._shouldUpdateDisplayedFollowUps(filteredSuggestions, timeSinceLastUpdate);
+        
+        if (shouldUpdateFollowUps && filteredSuggestions.length > 0) {
+            console.log(`[ResearchService] Updating displayed follow-up questions`);
+            this.lastFollowUpUpdateTime = now;
+            
+            // Add new questions that aren't already displayed
+            for (const suggestion of this.bestFollowUpQuestions) {
+                const isAlreadyDisplayed = this.displayedFollowUpQuestions.some(q => q.text === suggestion);
+                if (!isAlreadyDisplayed) {
+                    this.displayedFollowUpQuestions.push({
+                        text: suggestion,
+                        displayedAt: now,
+                        id: `followup_${now}_${Math.random().toString(36).substr(2, 9)}`
+                    });
+                    this.metrics.followUpsShown++;
+                    console.log(`[ResearchService] Added new follow-up question to display:`, suggestion);
+                }
+            }
+            
+            // Keep only top 2 displayed questions
+            if (this.displayedFollowUpQuestions.length > 2) {
+                this.displayedFollowUpQuestions = this.displayedFollowUpQuestions
+                    .sort((a, b) => b.displayedAt - a.displayedAt)
+                    .slice(0, 2);
+            }
+        } else {
+            if (filteredSuggestions.length === 0) {
+                console.log(`[ResearchService] No high-quality follow-ups to display`);
+            } else {
+                console.log(`[ResearchService] Skipping follow-up update - too soon or no significant changes`);
+            }
+        }
+        
+        console.log(`[ResearchService] Currently displaying ${this.displayedFollowUpQuestions.length} follow-up questions`);
+    }
+    
+    _shouldUpdateDisplayedFollowUps(newSuggestions, timeSinceLastUpdate) {
+        // If no questions are currently displayed, always update
+        if (this.displayedFollowUpQuestions.length === 0) {
+            return true;
+        }
+        
+        // Enforce minimum time between updates (unless it's been really long)
+        if (timeSinceLastUpdate < this.followUpUpdateInterval && timeSinceLastUpdate < 30000) {
+            return false;
+        }
+        
+        // Check if new suggestions are meaningfully different
+        const currentTexts = this.displayedFollowUpQuestions.map(q => q.text);
+        const newTexts = newSuggestions.slice(0, 2);
+        
+        // Calculate similarity - how many of the new suggestions are already displayed
+        const overlap = newTexts.filter(text => currentTexts.includes(text)).length;
+        const similarityRatio = overlap / Math.max(newTexts.length, 1);
+        
+        // Only update if suggestions are significantly different (less than 50% overlap)
+        const isDifferent = similarityRatio < 0.5;
+        
+        console.log(`[ResearchService] Follow-up similarity check: ${overlap}/${newTexts.length} overlap (${Math.round(similarityRatio * 100)}% similar), isDifferent: ${isDifferent}`);
+        
+        return isDifferent;
+    }
+    
+    expireOldFollowUpQuestions(currentTime) {
+        const expiredQuestions = [];
+        
+        this.displayedFollowUpQuestions = this.displayedFollowUpQuestions.filter(question => {
+            const age = currentTime - question.displayedAt;
+            const isBestQuestion = this.bestFollowUpQuestions.includes(question.text);
+            
+            // Keep if it's still one of the best questions OR if it's newer than timeout
+            if (isBestQuestion || age < this.followUpQuestionTimeout) {
+                return true;
+            } else {
+                expiredQuestions.push(question);
+                console.log(`[ResearchService] Expiring follow-up question after ${age}ms:`, question.text);
+                return false;
+            }
+        });
+        
+        // Emit expiration events for UI animations
+        if (expiredQuestions.length > 0) {
+            this.emit('followup-questions-expired', { expiredQuestions });
+        }
+    }
+    
+    getDisplayedFollowUpQuestions() {
+        const now = Date.now();
+        
+        // Clean up expired questions before returning
+        this.expireOldFollowUpQuestions(now);
+        
+        return this.displayedFollowUpQuestions.map(q => ({
+            id: q.id,
+            text: q.text,
+            displayedAt: q.displayedAt,
+            age: now - q.displayedAt
+        }));
+    }
+    
+    markFollowUpQuestionAsked(questionId, response = '') {
+        const question = this.displayedFollowUpQuestions.find(q => q.id === questionId);
+        if (question) {
+            this.followUpQuestionMetrics.totalAsked++;
+            this.followUpQuestionMetrics.responses.push({
+                question: question.text,
+                response: response,
+                askedAt: Date.now(),
+                questionId: questionId
+            });
+            
+            console.log(`[ResearchService] Follow-up question marked as asked:`, question.text);
+            console.log(`[ResearchService] Total asked: ${this.followUpQuestionMetrics.totalAsked}/${this.followUpQuestionMetrics.totalSuggested}`);
+        }
+    }
+
+    // ==================== METRICS AND TELEMETRY ====================
+    
+    _dumpSessionMetrics() {
+        console.log(`[ResearchService] ======= SESSION METRICS =======`);
+        console.log(`[ResearchService] Interviewer turns: ${this.metrics.interviewerTurns}`);
+        console.log(`[ResearchService] Question activations: ${this.metrics.questionActivations}`);
+        console.log(`[ResearchService] Participant turns: ${this.metrics.participantTurns}`);
+        console.log(`[ResearchService] Monotonic blocks: ${this.metrics.monotonicBlocks}`);
+        console.log(`[ResearchService] Follow-ups shown: ${this.metrics.followUpsShown}`);
+        
+        const activationRate = this.metrics.interviewerTurns > 0 ? 
+            (this.metrics.questionActivations / this.metrics.interviewerTurns * 100).toFixed(1) + '%' : 'N/A';
+        console.log(`[ResearchService] Question activation rate: ${activationRate}`);
+        console.log(`[ResearchService] ===============================`);
+    }
+
+    // ==================== STATUS AND UTILITIES ====================
+    
+    getSessionStatus() {
+        if (!this.currentSession || this.activeQuestions.size === 0) {
+            return null;
+        }
+        
+        const responses = Array.from(this.questionResponses.values());
+        const questionsAsked = responses.filter(r => r.status !== 'not_asked').length;
+        const questionsCompleted = responses.filter(r => r.status === 'complete').length;
+        const needFollowUp = responses.filter(r => r.follow_up_needed === 1).length;
+        
+        const questionBreakdown = {};
+        for (const [questionId, response] of this.questionResponses.entries()) {
+            const question = this.activeQuestions.get(questionId);
+            questionBreakdown[questionId] = {
+                text: question.question_text,
+                category: question.category,
+                priority: question.priority,
+                status: response.status,
+                completeness_score: response.completeness_score,
+                follow_up_needed: response.follow_up_needed === 1
+            };
+        }
+        
+        return {
+            studyTitle: this.currentStudy.title,
+            sessionId: this.currentSession.session_id,
+            totalQuestions: this.activeQuestions.size,
+            questionsAsked,
+            questionsCompleted,
+            needFollowUp,
+            completionPercentage: Math.round((questionsCompleted / this.activeQuestions.size) * 100),
+            questionBreakdown
+        };
+    }
+
+    calculateSessionQuality() {
+        const responses = Array.from(this.questionResponses.values());
+        if (responses.length === 0) return 0.0;
+        
+        const avgCompleteness = responses.reduce((sum, r) => sum + r.completeness_score, 0) / responses.length;
+        const requiredQuestions = Array.from(this.activeQuestions.values()).filter(q => q.is_required);
+        const requiredAnswered = requiredQuestions.filter(q => {
+            const response = this.questionResponses.get(q.id);
+            return response && response.status === 'complete';
+        }).length;
+        
+        const requiredScore = requiredQuestions.length > 0 ? requiredAnswered / requiredQuestions.length : 1.0;
+        
+        return (avgCompleteness * 0.7 + requiredScore * 0.3);
+    }
+
+    // ==================== EXPORT AND REPORTING ====================
+    
+    async getSessionReport(sessionId) {
+        const session = await researchSessionRepository.getById(sessionId);
+        if (!session) return null;
+        
+        const study = await researchStudyRepository.getById(session.study_id);
+        const responses = await questionResponseRepository.getBySessionId(sessionId);
+        
+        return {
+            session,
+            study,
+            responses: responses.map(r => ({
+                ...r,
+                key_insights: r.key_insights ? JSON.parse(r.key_insights) : []
+            }))
+        };
+    }
+}
+
+module.exports = new ResearchService(); 
\ No newline at end of file
diff --git a/src/preload.js b/src/preload.js
index d579fa7..72588b5 100644
--- a/src/preload.js
+++ b/src/preload.js
@@ -116,6 +116,7 @@ contextBridge.exposeInMainWorld('api', {
     // invoke: (channel, ...args) => ipcRenderer.invoke(channel, ...args),
     sendListenButtonClick: (listenButtonText) => ipcRenderer.invoke('listen:changeSession', listenButtonText),
     sendAskButtonClick: () => ipcRenderer.invoke('ask:toggleAskButton'),
+    sendResearchButtonClick: () => ipcRenderer.invoke('research:navigate-to-research'),
     sendToggleAllWindowsVisibility: () => ipcRenderer.invoke('shortcut:toggleAllWindowsVisibility'),
     
     // Listeners
@@ -302,5 +303,41 @@ contextBridge.exposeInMainWorld('api', {
     // Listeners
     onChangeListenCaptureState: (callback) => ipcRenderer.on('change-listen-capture-state', callback),
     removeOnChangeListenCaptureState: (callback) => ipcRenderer.removeListener('change-listen-capture-state', callback)
+  },
+
+  // src/ui/research/ResearchView.js
+  research: {
+    // Study Management
+    createStudy: (studyData) => ipcRenderer.invoke('research:create-study', studyData),
+    getAllStudies: () => ipcRenderer.invoke('research:get-all-studies'),
+    getStudy: (studyId) => ipcRenderer.invoke('research:get-study', studyId),
+    updateStudy: (studyId, updateData) => ipcRenderer.invoke('research:update-study', { studyId, updateData }),
+    deleteStudy: (studyId) => ipcRenderer.invoke('research:delete-study', studyId),
+
+    // Question Management  
+    addQuestion: (studyId, questionData) => ipcRenderer.invoke('research:add-question', { studyId, questionData }),
+    getStudyQuestions: (studyId) => ipcRenderer.invoke('research:get-study-questions', studyId),
+    updateQuestion: (questionId, updateData) => ipcRenderer.invoke('research:update-question', { questionId, updateData }),
+    deleteQuestion: (questionId) => ipcRenderer.invoke('research:delete-question', questionId),
+
+    // Session Management
+    startSession: (studyId, participantData) => ipcRenderer.invoke('research:start-session', { studyId, participantData }),
+    endSession: () => ipcRenderer.invoke('research:end-session'),
+    getSessionStatus: () => ipcRenderer.invoke('research:get-session-status'),
+    getSessionReport: (sessionId) => ipcRenderer.invoke('research:get-session-report', sessionId),
+
+    // Follow-up Question Management
+    markFollowUpAsked: (questionId, response) => ipcRenderer.invoke('research:mark-followup-asked', { questionId, response }),
+    getFollowUpMetrics: () => ipcRenderer.invoke('research:get-followup-metrics'),
+
+    // Event Listeners
+    onSessionStarted: (callback) => ipcRenderer.on('research:session-started', callback),
+    onSessionEnded: (callback) => ipcRenderer.on('research:session-ended', callback),
+    onAnalysisUpdate: (callback) => ipcRenderer.on('research:analysis-update', callback),
+    onFollowUpExpired: (callback) => ipcRenderer.on('research:followup-expired', callback),
+    removeOnSessionStarted: (callback) => ipcRenderer.removeListener('research:session-started', callback),
+    removeOnSessionEnded: (callback) => ipcRenderer.removeListener('research:session-ended', callback),
+    removeOnAnalysisUpdate: (callback) => ipcRenderer.removeListener('research:analysis-update', callback),
+    removeOnFollowUpExpired: (callback) => ipcRenderer.removeListener('research:followup-expired', callback)
   }
 });
\ No newline at end of file
diff --git a/src/ui/app/MainHeader.js b/src/ui/app/MainHeader.js
index 175c71d..46b7365 100644
--- a/src/ui/app/MainHeader.js
+++ b/src/ui/app/MainHeader.js
@@ -562,6 +562,25 @@ export class MainHeader extends LitElement {
         }
     }
 
+    async _handleResearchClick() {
+        if (this.wasJustDragged) return;
+
+        try {
+            console.log('[MainHeader] Research button clicked, attempting navigation');
+            
+            if (!window.api) {
+                console.error('[MainHeader] window.api not available');
+                return;
+            }
+
+            // Use the new IPC method to navigate to research view
+            await window.api.mainHeader.sendResearchButtonClick();
+            console.log('[MainHeader] Research navigation request sent successfully');
+        } catch (error) {
+            console.error('[MainHeader] Failed to navigate to research view:', error);
+        }
+    }
+
     async _handleToggleAllWindowsVisibility() {
         if (this.wasJustDragged) return;
 
@@ -651,6 +670,15 @@ export class MainHeader extends LitElement {
                     </div>
                 </div>
 
+                <div class="header-actions" @click=${() => this._handleResearchClick()}>
+                    <div class="action-text">
+                        <div class="action-text-content">Research</div>
+                    </div>
+                    <div class="icon-container">
+                        <div class="icon-box">üìä</div>
+                    </div>
+                </div>
+
                 <div class="header-actions" @click=${() => this._handleToggleAllWindowsVisibility()}>
                     <div class="action-text">
                         <div class="action-text-content">Show/Hide</div>
diff --git a/src/ui/app/PickleGlassApp.js b/src/ui/app/PickleGlassApp.js
index df920c3..4c90d11 100644
--- a/src/ui/app/PickleGlassApp.js
+++ b/src/ui/app/PickleGlassApp.js
@@ -3,6 +3,7 @@ import { SettingsView } from '../settings/SettingsView.js';
 import { ListenView } from '../listen/ListenView.js';
 import { AskView } from '../ask/AskView.js';
 import { ShortcutSettingsView } from '../settings/ShortCutSettingsView.js';
+import { ResearchView } from '../research/ResearchView.js';
 
 import '../listen/audioCore/renderer.js';
 
@@ -23,7 +24,7 @@ export class PickleGlassApp extends LitElement {
             height: 100%;
         }
 
-        ask-view, settings-view, history-view, help-view, setup-view {
+        ask-view, settings-view, research-view, history-view, help-view, setup-view {
             display: block;
             width: 100%;
             height: 100%;
@@ -53,6 +54,8 @@ export class PickleGlassApp extends LitElement {
         const urlParams = new URLSearchParams(window.location.search);
         this.currentView = urlParams.get('view') || 'listen';
         this.currentResponseIndex = -1;
+        
+        console.log('[PickleGlassApp] Initialized with view:', this.currentView, 'URL:', window.location.href);
         this.selectedProfile = localStorage.getItem('selectedProfile') || 'interview';
         
         // Language format migration for legacy users
@@ -127,6 +130,7 @@ export class PickleGlassApp extends LitElement {
 
 
     render() {
+        console.log('[PickleGlassApp] Rendering with currentView:', this.currentView);
         switch (this.currentView) {
             case 'listen':
                 return html`<listen-view
@@ -146,6 +150,8 @@ export class PickleGlassApp extends LitElement {
                 ></settings-view>`;
             case 'shortcut-settings':
                 return html`<shortcut-settings-view></shortcut-settings-view>`;
+            case 'research':
+                return html`<research-view></research-view>`;
             case 'history':
                 return html`<history-view></history-view>`;
             case 'help':
@@ -159,3 +165,4 @@ export class PickleGlassApp extends LitElement {
 }
 
 customElements.define('pickle-glass-app', PickleGlassApp);
+customElements.define('research-view', ResearchView);
diff --git a/src/ui/listen/audioCore/renderer.js b/src/ui/listen/audioCore/renderer.js
index f4ed906..481a116 100644
--- a/src/ui/listen/audioCore/renderer.js
+++ b/src/ui/listen/audioCore/renderer.js
@@ -15,10 +15,9 @@ window.pickleGlass = {
 
 
 window.api.renderer.onChangeListenCaptureState((_event, { status }) => {
-    if (!isListenView) {
-        console.log('[Renderer] Non-listen view: ignoring capture-state change');
-        return;
-    }
+    // Allow capture in any view mode (including research mode)
+    console.log(`[Renderer] Capture state change: ${status} (view: ${params.get('view') || 'unknown'})`);
+    
     if (status === "stop") {
         console.log('[Renderer] Session ended ‚Äì stopping local capture');
         listenCapture.stopCapture();
diff --git a/src/ui/research/ResearchView.js b/src/ui/research/ResearchView.js
new file mode 100644
index 0000000..2d73df5
--- /dev/null
+++ b/src/ui/research/ResearchView.js
@@ -0,0 +1,1282 @@
+import { html, css, LitElement } from '../assets/lit-core-2.7.4.min.js';
+
+export class ResearchView extends LitElement {
+    static styles = css`
+        :host {
+            display: block;
+            width: 100%;
+            height: 100%;
+            padding: 12px;
+            background: rgba(255, 255, 255, 0.98);
+            border-radius: 8px;
+            color: var(--text-color);
+            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
+        }
+
+        .research-container {
+            display: flex;
+            flex-direction: column;
+            height: 100%;
+            gap: 12px;
+            overflow-y: auto;
+            overflow-x: hidden;
+        }
+
+        .research-header {
+            display: flex;
+            justify-content: space-between;
+            align-items: center;
+            padding-bottom: 8px;
+            padding-right: 16px;
+            border-bottom: 1px solid #e0e0e0;
+        }
+
+        .research-title {
+            font-size: 18px;
+            font-weight: 600;
+            color: #2d3748;
+        }
+
+        .research-mode {
+            padding: 6px 12px;
+            background: #4299e1;
+            color: white;
+            border-radius: 6px;
+            font-size: 12px;
+            font-weight: 500;
+            text-transform: uppercase;
+            margin-right: 12px;
+            flex-shrink: 0;
+        }
+
+        .research-mode.setup { background: #ed8936; }
+        .research-mode.live { background: #48bb78; }
+        .research-mode.analysis { background: #9f7aea; }
+
+        .setup-wizard {
+            display: flex;
+            flex-direction: column;
+            gap: 12px;
+        }
+
+        .wizard-section {
+            background: #f7fafc;
+            padding: 12px;
+            border-radius: 6px;
+            border: 1px solid #e2e8f0;
+        }
+
+        .wizard-section h3 {
+            margin: 0 0 8px 0;
+            font-size: 14px;
+            font-weight: 600;
+            color: #2d3748;
+        }
+
+        .form-group {
+            display: flex;
+            flex-direction: column;
+            gap: 4px;
+            margin-bottom: 10px;
+        }
+
+        .form-group label {
+            font-size: 12px;
+            font-weight: 500;
+            color: #4a5568;
+        }
+
+        .form-group input,
+        .form-group textarea,
+        .form-group select {
+            padding: 6px 8px;
+            border: 1px solid #d1d5db;
+            border-radius: 4px;
+            font-size: 12px;
+            font-family: inherit;
+        }
+
+        .form-group textarea {
+            resize: vertical;
+            min-height: 50px;
+        }
+
+        .questions-list {
+            display: flex;
+            flex-direction: column;
+            gap: 6px;
+            max-height: 200px;
+            overflow-y: auto;
+        }
+
+        .question-item {
+            display: flex;
+            justify-content: space-between;
+            align-items: flex-start;
+            padding: 8px;
+            background: white;
+            border: 1px solid #e2e8f0;
+            border-radius: 4px;
+            gap: 8px;
+        }
+
+        .question-content {
+            flex: 1;
+            display: flex;
+            flex-direction: column;
+            gap: 4px;
+        }
+
+        .question-text {
+            font-size: 14px;
+            color: #2d3748;
+            line-height: 1.4;
+        }
+
+        .question-meta {
+            display: flex;
+            gap: 8px;
+            font-size: 12px;
+        }
+
+        .question-category {
+            padding: 2px 6px;
+            background: #bee3f8;
+            color: #2b6cb0;
+            border-radius: 4px;
+        }
+
+        .question-priority {
+            padding: 2px 6px;
+            border-radius: 4px;
+        }
+
+        .question-priority.high { background: #fed7d7; color: #c53030; }
+        .question-priority.medium { background: #feebc8; color: #c05621; }
+        .question-priority.low { background: #c6f6d5; color: #2f855a; }
+
+        .question-actions {
+            display: flex;
+            gap: 6px;
+        }
+
+        .btn {
+            padding: 6px 12px;
+            border: none;
+            border-radius: 4px;
+            font-size: 12px;
+            font-weight: 500;
+            cursor: pointer;
+            transition: all 0.2s;
+        }
+
+        .btn-small {
+            padding: 4px 8px;
+            font-size: 11px;
+        }
+
+        .btn-primary {
+            background: #4299e1;
+            color: white;
+        }
+
+        .btn-primary:hover {
+            background: #3182ce;
+        }
+
+        .btn-secondary {
+            background: #e2e8f0;
+            color: #4a5568;
+        }
+
+        .btn-secondary:hover {
+            background: #cbd5e0;
+        }
+
+        .btn-danger {
+            background: #f56565;
+            color: white;
+        }
+
+        .btn-danger:hover {
+            background: #e53e3e;
+        }
+
+        .btn-small {
+            padding: 3px 6px;
+            font-size: 10px;
+        }
+
+        .live-dashboard {
+            display: flex;
+            flex-direction: column;
+            gap: 10px;
+            min-height: 100%;
+            padding-bottom: 20px; /* Extra space at bottom for scrolling */
+        }
+
+        .session-status {
+            display: grid;
+            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
+            gap: 12px;
+            padding: 16px;
+            background: #f7fafc;
+            border-radius: 8px;
+        }
+
+        .status-card {
+            text-align: center;
+            padding: 12px;
+            background: white;
+            border-radius: 6px;
+            border: 1px solid #e2e8f0;
+        }
+
+        .status-number {
+            font-size: 24px;
+            font-weight: 700;
+            color: #2d3748;
+            display: block;
+        }
+
+        .status-label {
+            font-size: 12px;
+            color: #718096;
+            text-transform: uppercase;
+            margin-top: 4px;
+        }
+
+        .live-questions {
+            flex: 1;
+            display: flex;
+            flex-direction: column;
+            gap: 8px;
+            overflow-y: auto;
+        }
+
+        .live-question {
+            display: flex;
+            align-items: center;
+            padding: 12px;
+            background: white;
+            border: 1px solid #e2e8f0;
+            border-radius: 6px;
+            gap: 12px;
+        }
+
+        .question-status-indicator {
+            width: 12px;
+            height: 12px;
+            border-radius: 50%;
+            flex-shrink: 0;
+        }
+
+        .question-status-indicator.not-asked { background: #e2e8f0; }
+        .question-status-indicator.partial { background: #fbb6ce; }
+        .question-status-indicator.complete { background: #9ae6b4; }
+        .question-status-indicator.needs-clarification { background: #fbd38d; }
+
+        .suggestions-panel {
+            background: #f0fff4;
+            border: 1px solid #9ae6b4;
+            border-radius: 8px;
+            padding: 16px;
+        }
+
+        .suggestions-title {
+            font-size: 16px;
+            font-weight: 600;
+            color: #2f855a;
+            margin-bottom: 12px;
+        }
+
+        .suggestion-item {
+            padding: 8px 12px;
+            background: white;
+            border: 1px solid #c6f6d5;
+            border-radius: 6px;
+            margin-bottom: 8px;
+            font-size: 14px;
+            color: #2d3748;
+        }
+
+        .hidden {
+            display: none;
+        }
+
+        .add-question-form {
+            display: flex;
+            flex-direction: column;
+            gap: 12px;
+            background: #f7fafc;
+            padding: 16px;
+            border-radius: 8px;
+            border: 1px solid #e2e8f0;
+        }
+
+        /* New Live Dashboard Styles */
+        .section {
+            background: white;
+            border: 1px solid #e2e8f0;
+            border-radius: 8px;
+            padding: 16px;
+            margin-bottom: 16px;
+        }
+
+        .section-title {
+            margin: 0 0 12px 0;
+            font-size: 16px;
+            font-weight: 600;
+            color: #2d3748;
+        }
+
+        .section-title.collapsible {
+            cursor: pointer;
+            display: flex;
+            align-items: center;
+            gap: 8px;
+            user-select: none;
+        }
+
+        .section-title.collapsible:hover {
+            color: #4299e1;
+        }
+
+        .collapse-icon {
+            font-size: 12px;
+            transition: transform 0.2s ease;
+        }
+
+        .collapse-icon.expanded {
+            transform: rotate(90deg);
+        }
+
+        .collapsible-content {
+            max-height: 0;
+            overflow: hidden;
+            transition: max-height 0.3s ease, padding 0.3s ease;
+            padding-top: 0;
+            padding-bottom: 0;
+        }
+
+        .collapsible-content.expanded {
+            max-height: 500px;
+            padding-top: 8px;
+            padding-bottom: 8px;
+        }
+
+        /* Suggested Follow-ups */
+        .suggested-followups {
+            background: linear-gradient(135deg, #f0fff4, #e6fffa);
+            border-color: #9ae6b4;
+        }
+
+        .followups-container {
+            display: flex;
+            flex-direction: column;
+            gap: 0px; /* Removed gap since we're using margin-bottom in animations */
+        }
+
+        .followup-item {
+            padding: 12px;
+            background: white;
+            border: 1px solid #c6f6d5;
+            border-radius: 6px;
+            color: #2d3748;
+            border-left: 4px solid #48bb78;
+            cursor: pointer;
+            transition: all 0.3s ease;
+            opacity: 0;
+            transform: translateY(10px);
+            animation: fadeIn 0.5s ease-out forwards;
+        }
+
+        .followup-item:hover {
+            background: #f0fff4;
+            border-color: #9ae6b4;
+            transform: translateY(-1px);
+            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
+        }
+
+        .followup-item.expiring {
+            animation: fadeOut 0.5s ease-out forwards;
+        }
+
+        @keyframes fadeIn {
+            0% {
+                opacity: 0;
+                transform: translateY(10px);
+                max-height: 0;
+                padding-top: 0;
+                padding-bottom: 0;
+                margin-bottom: 0;
+            }
+            100% {
+                opacity: 1;
+                transform: translateY(0);
+                max-height: 100px;
+                padding-top: 12px;
+                padding-bottom: 12px;
+                margin-bottom: 8px;
+            }
+        }
+
+        @keyframes fadeOut {
+            0% {
+                opacity: 1;
+                transform: translateY(0);
+                max-height: 100px;
+                padding-top: 12px;
+                padding-bottom: 12px;
+                margin-bottom: 8px;
+            }
+            100% {
+                opacity: 0;
+                transform: translateY(-10px);
+                max-height: 0;
+                padding-top: 0;
+                padding-bottom: 0;
+                margin-bottom: 0;
+            }
+        }
+
+        .followup-text {
+            font-size: 14px;
+            line-height: 1.4;
+            margin-bottom: 4px;
+        }
+
+        .followup-age {
+            font-size: 11px;
+            color: #718096;
+            opacity: 0.7;
+        }
+
+        .followup-stats {
+            font-size: 12px;
+            color: #718096;
+            font-weight: normal;
+            margin-left: 8px;
+        }
+
+        /* Current Question */
+        .current-question {
+            background: linear-gradient(135deg, #fff5f5, #fef5e7);
+            border-color: #fed7d7;
+        }
+
+        .question-display {
+            display: flex;
+            flex-direction: column;
+            gap: 12px;
+        }
+
+        .question-text {
+            font-size: 16px;
+            font-weight: 500;
+            color: #2d3748;
+            line-height: 1.4;
+        }
+
+        .answer-section {
+            background: white;
+            padding: 12px;
+            border-radius: 6px;
+            border: 1px solid #e2e8f0;
+        }
+
+        .answer-label {
+            font-size: 12px;
+            font-weight: 600;
+            color: #4a5568;
+            margin-bottom: 6px;
+        }
+
+        .answer-text {
+            font-size: 14px;
+            color: #2d3748;
+            margin-bottom: 8px;
+            min-height: 20px;
+            font-style: italic;
+        }
+
+        .completeness-bar {
+            width: 100%;
+            height: 6px;
+            background: #e2e8f0;
+            border-radius: 3px;
+            overflow: hidden;
+            margin-bottom: 4px;
+        }
+
+        .completeness-fill {
+            height: 100%;
+            background: linear-gradient(90deg, #ed8936, #48bb78);
+            transition: width 0.3s ease;
+        }
+
+        .completeness-label {
+            font-size: 12px;
+            color: #718096;
+            text-align: right;
+        }
+
+        .no-current-question, .no-next-question {
+            color: #718096;
+            font-style: italic;
+            text-align: center;
+            padding: 20px;
+        }
+
+        /* Next Question */
+        .next-question {
+            background: linear-gradient(135deg, #ebf8ff, #e6fffa);
+            border-color: #bee3f8;
+        }
+
+        .next-question-display {
+            display: flex;
+            flex-direction: column;
+            gap: 8px;
+        }
+
+        .next-question-text {
+            font-size: 15px;
+            font-weight: 500;
+            color: #2d3748;
+        }
+
+        .next-question-reason {
+            font-size: 12px;
+            color: #4a5568;
+            background: white;
+            padding: 6px 10px;
+            border-radius: 4px;
+            border: 1px solid #e2e8f0;
+            align-self: flex-start;
+        }
+
+
+
+        /* Question Items */
+        .question-item {
+            display: flex;
+            align-items: flex-start;
+            padding: 12px;
+            background: #f7fafc;
+            border: 1px solid #e2e8f0;
+            border-radius: 6px;
+            margin-bottom: 8px;
+            gap: 12px;
+        }
+
+        .question-item:last-child {
+            margin-bottom: 0;
+        }
+
+        .question-content {
+            flex: 1;
+            display: flex;
+            flex-direction: column;
+            gap: 6px;
+        }
+
+        .status-badge {
+            padding: 2px 6px;
+            border-radius: 4px;
+            font-size: 10px;
+            text-transform: uppercase;
+            font-weight: 600;
+        }
+
+        .status-badge.partial { background: #fbb6ce; color: #97266d; }
+        .status-badge.complete { background: #9ae6b4; color: #2f855a; }
+        .status-badge.needs-clarification { background: #fbd38d; color: #c05621; }
+
+        /* Session Controls */
+        .session-controls {
+            display: flex;
+            justify-content: space-between;
+            align-items: center;
+            padding: 16px;
+            background: #f7fafc;
+            border-radius: 8px;
+            border: 1px solid #e2e8f0;
+        }
+
+        .session-stats {
+            display: flex;
+            gap: 16px;
+        }
+
+        .stat {
+            font-size: 14px;
+            color: #4a5568;
+            font-weight: 500;
+        }
+
+        .empty-state {
+            color: #a0aec0;
+            font-style: italic;
+            text-align: center;
+            padding: 12px;
+        }
+    `;
+
+    static properties = {
+        mode: { type: String }, // 'setup', 'live', 'analysis'
+        currentStudy: { type: Object },
+        questions: { type: Array },
+        sessionStatus: { type: Object },
+        suggestions: { type: Array },
+        studies: { type: Array },
+        showAddQuestion: { type: Boolean, state: true },
+        showAllQuestions: { type: Boolean, state: true },
+        currentQuestion: { type: Object }, // Current question being asked
+        nextQuestion: { type: Object }, // Next question to ask
+        showPendingQuestions: { type: Boolean, state: true },
+        showAskedQuestions: { type: Boolean, state: true },
+        followUpMetrics: { type: Object }, // Follow-up question analytics
+        expiringQuestions: { type: Set, state: true } // Questions currently fading out
+    };
+
+    constructor() {
+        super();
+        this.mode = 'setup';
+        this.currentStudy = null;
+        this.questions = [];
+        this.sessionStatus = null;
+        this.suggestions = [];
+        this.studies = [];
+        this.showAddQuestion = false;
+        this.showAllQuestions = false;
+        this.currentQuestion = null;
+        this.nextQuestion = null;
+        this.showPendingQuestions = false;
+        this.showAskedQuestions = false;
+        this.followUpMetrics = { totalSuggested: 0, totalAsked: 0, responses: [] };
+        this.expiringQuestions = new Set();
+        
+        // Auto-create fintech study for demo
+        setTimeout(() => this._autoCreateFintechStudy(), 1000);
+    }
+
+    connectedCallback() {
+        super.connectedCallback();
+        
+        console.log('[ResearchView] Connected to DOM');
+        
+        // Add event listeners only if window.api exists
+        if (window.api) {
+            try {
+                // Listen for research events
+                window.api.research.onSessionStarted(this._handleSessionStarted.bind(this));
+                window.api.research.onSessionEnded(this._handleSessionEnded.bind(this));
+                window.api.research.onAnalysisUpdate(this._handleAnalysisUpdate.bind(this));
+                window.api.research.onFollowUpExpired(this._handleFollowUpExpired.bind(this));
+                console.log('[ResearchView] Event listeners added');
+            } catch (error) {
+                console.error('[ResearchView] Failed to add event listeners:', error);
+            }
+        } else {
+            console.warn('[ResearchView] window.api not available, running in demo mode');
+        }
+        
+        // Load studies with error handling
+        this.loadStudies().catch(error => {
+            console.error('[ResearchView] Failed to load studies:', error);
+        });
+    }
+
+    disconnectedCallback() {
+        super.disconnectedCallback();
+        if (window.api) {
+            window.api.research.removeOnSessionStarted(this._handleSessionStarted.bind(this));
+            window.api.research.removeOnSessionEnded(this._handleSessionEnded.bind(this));
+            window.api.research.removeOnAnalysisUpdate(this._handleAnalysisUpdate.bind(this));
+        }
+    }
+
+    async loadStudies() {
+        try {
+            if (!window.api) {
+                console.log('[ResearchView] API not available, using demo data');
+                this.studies = []; // Empty array for now
+                return;
+            }
+            
+            const studies = await window.api.research.getAllStudies();
+            this.studies = studies || [];
+            console.log('[ResearchView] Loaded studies:', this.studies.length);
+        } catch (error) {
+            console.error('[ResearchView] Failed to load studies:', error);
+            this.studies = []; // Fallback to empty array
+        }
+    }
+
+    async createStudy(studyData) {
+        try {
+            console.log('[ResearchView] Calling API to create study:', studyData);
+            const study = await window.api.research.createStudy(studyData);
+            console.log('[ResearchView] Study created successfully:', study);
+            this.currentStudy = study;
+            this.mode = 'setup';
+            await this.loadQuestions();
+            // Force a re-render to update the UI
+            this.requestUpdate();
+        } catch (error) {
+            console.error('[ResearchView] Failed to create study:', error);
+        }
+    }
+
+    async loadQuestions() {
+        if (!this.currentStudy) return;
+        
+        try {
+            const questions = await window.api.research.getStudyQuestions(this.currentStudy.id);
+            this.questions = questions;
+        } catch (error) {
+            console.error('Failed to load questions:', error);
+        }
+    }
+
+    async addQuestion(questionData) {
+        if (!this.currentStudy) return;
+        
+        try {
+            await window.api.research.addQuestion(this.currentStudy.id, questionData);
+            await this.loadQuestions();
+            this.showAddQuestion = false;
+        } catch (error) {
+            console.error('Failed to add question:', error);
+        }
+    }
+
+    async startResearchSession(participantData) {
+        if (!this.currentStudy) return;
+        
+        try {
+            const result = await window.api.research.startSession(this.currentStudy.id, participantData);
+            this.sessionStatus = result.status;
+            this.mode = 'live';
+        } catch (error) {
+            console.error('Failed to start research session:', error);
+        }
+    }
+
+    async endResearchSession() {
+        try {
+            await window.api.research.endSession();
+            this.mode = 'analysis';
+        } catch (error) {
+            console.error('Failed to end research session:', error);
+        }
+    }
+
+    _handleSessionStarted(event, data) {
+        console.log('Research session started:', data);
+        this.mode = 'live';
+    }
+
+    _handleSessionEnded(event, data) {
+        console.log('Research session ended:', data);
+        this.mode = 'analysis';
+    }
+
+    _handleAnalysisUpdate(event, data) {
+        console.log('Research analysis update:', data);
+        this.sessionStatus = data.status;
+        this.suggestions = data.suggestions || [];
+        this.currentQuestion = data.currentQuestion || null;
+        this.nextQuestion = data.nextQuestion || null;
+        this.followUpMetrics = data.followUpMetrics || this.followUpMetrics;
+        this.requestUpdate(); // Force re-render to show updated data
+    }
+
+    _handleFollowUpExpired(event, data) {
+        console.log('Follow-up questions expired:', data.expiredQuestions);
+        // Add expired questions to the expiring set for fade animation
+        data.expiredQuestions.forEach(question => {
+            this.expiringQuestions.add(question.id);
+        });
+        
+        // Remove from expiring set after animation duration
+        setTimeout(() => {
+            data.expiredQuestions.forEach(question => {
+                this.expiringQuestions.delete(question.id);
+            });
+            this.requestUpdate();
+        }, 500); // 500ms for fade animation (questions expire after 10s)
+        
+        this.requestUpdate();
+    }
+
+    async _markFollowUpAsAsked(questionId) {
+        try {
+            if (window.api) {
+                await window.api.research.markFollowUpAsked(questionId);
+                console.log('[ResearchView] Marked follow-up question as asked:', questionId);
+            }
+        } catch (error) {
+            console.error('[ResearchView] Failed to mark follow-up as asked:', error);
+        }
+    }
+
+
+
+    async _autoCreateFintechStudy() {
+        try {
+            // Check if we already have a study
+            if (this.currentStudy) return;
+            
+            console.log('[ResearchView] Auto-creating fintech study...');
+            
+            const fintechStudy = {
+                title: "What features do you expect from a fintech app?",
+                description: "UX research study to understand user expectations and preferences for fintech applications",
+                research_type: "user_interview",
+                methodology: "semi_structured",
+                participant_profile: "Age 18-30",
+                goals: "Understand user expectations, identify pain points, and discover desired features for fintech apps"
+            };
+
+            // Create the study
+            await this.createStudy(fintechStudy);
+
+            // Add predefined questions
+            const fintechQuestions = [
+                {
+                    question_text: "Can you describe your current experience with using fintech apps in general?",
+                    category: "experience",
+                    priority: "high",
+                    is_required: true
+                },
+                {
+                    question_text: "What are the most important tasks you want to accomplish using a fintech app?",
+                    category: "needs",
+                    priority: "high",
+                    is_required: true
+                },
+                {
+                    question_text: "Can you tell me about a time when a fintech app exceeded your expectations? What features stood out to you?",
+                    category: "positive_experience",
+                    priority: "medium",
+                    is_required: false
+                },
+                {
+                    question_text: "What are some frustrations or challenges you've encountered while using fintech apps?",
+                    category: "pain_points",
+                    priority: "high",
+                    is_required: true
+                },
+                {
+                    question_text: "How do you usually decide which fintech app to use? What factors influence your decision?",
+                    category: "decision_making",
+                    priority: "medium",
+                    is_required: false
+                },
+                {
+                    question_text: "Can you imagine an ideal fintech app that perfectly meets your needs? What features would it include?",
+                    category: "ideal_features",
+                    priority: "high",
+                    is_required: true
+                },
+                {
+                    question_text: "How do you prioritize different features in a fintech app? For example, security, ease of use, or variety of services?",
+                    category: "prioritization",
+                    priority: "medium",
+                    is_required: false
+                },
+                {
+                    question_text: "If you could improve one feature in the fintech apps you currently use, what would it be and why?",
+                    category: "improvement",
+                    priority: "medium",
+                    is_required: false
+                },
+                {
+                    question_text: "How do you feel about the security measures in fintech apps? Are there any specific features you expect in this area?",
+                    category: "security",
+                    priority: "high",
+                    is_required: true
+                }
+            ];
+
+            // Add all questions
+            for (let i = 0; i < fintechQuestions.length; i++) {
+                const questionData = { ...fintechQuestions[i], order_index: i };
+                await this.addQuestion(questionData);
+            }
+
+            console.log('[ResearchView] Fintech study created with', fintechQuestions.length, 'questions');
+            
+            // Auto-start the research session for demo purposes
+            console.log('[ResearchView] Auto-starting research session for demo...');
+            await this._startSession();
+            
+        } catch (error) {
+            console.error('[ResearchView] Failed to auto-create fintech study:', error);
+        }
+    }
+
+    render() {
+        console.log('[ResearchView] Rendering with mode:', this.mode);
+        
+        return html`
+            <div class="research-container">
+                <div class="research-header">
+                    <h2 class="research-title">
+                        ${this.currentStudy ? this.currentStudy.title : 'UX Research Assistant'}
+                    </h2>
+                    <div class="research-mode ${this.mode}">${this.mode}</div>
+                </div>
+
+
+
+                ${this.mode === 'setup' ? this.renderSetupWizard() : ''}
+                ${this.mode === 'live' ? this.renderLiveDashboard() : ''}
+                ${this.mode === 'analysis' ? this.renderAnalysisDashboard() : ''}
+            </div>
+        `;
+    }
+
+    renderSetupWizard() {
+        return html`
+            <div class="setup-wizard">
+                ${!this.currentStudy ? this.renderStudyCreation() : ''}
+                ${this.currentStudy ? this.renderQuestionSetup() : ''}
+            </div>
+        `;
+    }
+
+    renderStudyCreation() {
+        return html`
+            <div class="wizard-section">
+                <h3>Create Research Study</h3>
+                <form @submit="${this._handleStudySubmit}">
+                    <div class="form-group">
+                        <label for="study-title">Study Title</label>
+                        <input type="text" id="study-title" name="title" required 
+                               placeholder="e.g., Mobile Banking App Usability Study">
+                    </div>
+                    
+                    <div class="form-group">
+                        <label for="study-description">Description</label>
+                        <textarea id="study-description" name="description"
+                                  placeholder="Brief description of the study objectives and scope"></textarea>
+                    </div>
+                    
+                    <div class="form-group">
+                        <label for="research-type">Research Type</label>
+                        <select id="research-type" name="research_type">
+                            <option value="user_interview">User Interview</option>
+                            <option value="usability_test">Usability Test</option>
+                            <option value="focus_group">Focus Group</option>
+                        </select>
+                    </div>
+                    
+                    <div class="form-group">
+                        <label for="methodology">Methodology</label>
+                        <select id="methodology" name="methodology">
+                            <option value="semi_structured">Semi-structured</option>
+                            <option value="structured">Structured</option>
+                            <option value="unstructured">Unstructured</option>
+                        </select>
+                    </div>
+                    
+                    <div class="form-group">
+                        <label for="participant-profile">Participant Profile</label>
+                        <textarea id="participant-profile" name="participant_profile"
+                                  placeholder="Target user demographics, experience level, etc."></textarea>
+                    </div>
+                    
+                    <div class="form-group">
+                        <label for="goals">Study Goals</label>
+                        <textarea id="goals" name="goals"
+                                  placeholder="Key research questions and objectives"></textarea>
+                    </div>
+                    
+                    <button type="submit" class="btn btn-primary">Create Study</button>
+                </form>
+            </div>
+        `;
+    }
+
+    renderQuestionSetup() {
+        return html`
+            <div class="wizard-section">
+                <h3>Interview Questions (${this.questions.length})</h3>
+                
+                <div class="questions-list">
+                    ${this.questions.map((question, index) => html`
+                        <div class="question-item">
+                            <div class="question-content">
+                                <div class="question-text">${question.question_text}</div>
+                                <div class="question-meta">
+                                    <span class="question-category">${question.category}</span>
+                                    <span class="question-priority ${question.priority}">${question.priority}</span>
+                                    ${question.is_required ? html`<span class="question-priority high">required</span>` : ''}
+                                </div>
+                            </div>
+                            <div class="question-actions">
+                                <button class="btn btn-secondary btn-small" 
+                                        @click="${() => this._editQuestion(question)}">Edit</button>
+                                <button class="btn btn-danger btn-small"
+                                        @click="${() => this._deleteQuestion(question.id)}">Delete</button>
+                            </div>
+                        </div>
+                    `)}
+                </div>
+
+                ${this.showAddQuestion ? this.renderAddQuestionForm() : html`
+                    <button class="btn btn-secondary" @click="${() => this.showAddQuestion = true}">
+                        Add Question
+                    </button>
+                `}
+
+                <div style="display: flex; gap: 12px; margin-top: 20px;">
+                    <button class="btn btn-primary" 
+                            @click="${this._startSession}"
+                            ?disabled="${this.questions.length === 0}">
+                        Start Research Session
+                    </button>
+                </div>
+            </div>
+        `;
+    }
+
+    renderAddQuestionForm() {
+        return html`
+            <div class="add-question-form">
+                <form @submit="${this._handleQuestionSubmit}">
+                    <div class="form-group">
+                        <label for="question-text">Question</label>
+                        <textarea id="question-text" name="question_text" required
+                                  placeholder="What is your primary goal when using this feature?"></textarea>
+                    </div>
+                    
+                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
+                        <div class="form-group">
+                            <label for="question-category">Category</label>
+                            <select id="question-category" name="category">
+                                <option value="background">Background</option>
+                                <option value="behavior">Behavior</option>
+                                <option value="attitude">Attitude</option>
+                                <option value="demographic">Demographic</option>
+                            </select>
+                        </div>
+                        
+                        <div class="form-group">
+                            <label for="question-priority">Priority</label>
+                            <select id="question-priority" name="priority">
+                                <option value="high">High</option>
+                                <option value="medium">Medium</option>
+                                <option value="low">Low</option>
+                            </select>
+                        </div>
+                        
+                        <div class="form-group">
+                            <label for="question-required">
+                                <input type="checkbox" id="question-required" name="is_required"> Required
+                            </label>
+                        </div>
+                    </div>
+                    
+                    <div style="display: flex; gap: 12px;">
+                        <button type="submit" class="btn btn-primary">Add Question</button>
+                        <button type="button" class="btn btn-secondary"
+                                @click="${() => this.showAddQuestion = false}">Cancel</button>
+                    </div>
+                </form>
+            </div>
+        `;
+    }
+
+    renderLiveDashboard() {
+        if (!this.sessionStatus) return html`<div>Loading session...</div>`;
+
+        const allQuestions = Object.entries(this.sessionStatus.questionBreakdown || {});
+        const pendingQuestions = allQuestions.filter(([id, q]) => q.status === 'not_asked');
+        const askedQuestions = allQuestions.filter(([id, q]) => q.status !== 'not_asked');
+
+        return html`
+            <div class="live-dashboard">
+                <!-- Suggested Follow-ups Section -->
+                ${this.suggestions.length > 0 ? html`
+                    <div class="section suggested-followups">
+                        <h3 class="section-title">
+                            üí° Suggested Follow-ups 
+                            <span class="followup-stats">(${this.followUpMetrics.totalAsked}/${this.followUpMetrics.totalSuggested} asked)</span>
+                        </h3>
+                        <div class="followups-container">
+                            ${this.suggestions.map((suggestion, index) => html`
+                                <div class="followup-item ${this.expiringQuestions.has(suggestion.id) ? 'expiring' : ''}"
+                                     @click="${() => this._markFollowUpAsAsked(suggestion.id)}"
+                                     data-age="${suggestion.age}ms"
+                                     style="animation-delay: ${this.expiringQuestions.has(suggestion.id) ? '0s' : (index * 0.1) + 's'}">
+                                    <div class="followup-text">${suggestion.text}</div>
+                                    <div class="followup-age">shown ${Math.round(suggestion.age / 1000)}s ago</div>
+                                </div>
+                            `)}
+                        </div>
+                    </div>
+                ` : ''}
+
+                <!-- Current Question Being Asked Section -->
+                <div class="section current-question">
+                    <h3 class="section-title">üéØ Current Question Being Asked</h3>
+                    <div class="current-question-content">
+                        ${this.currentQuestion ? html`
+                            <div class="question-display">
+                                <div class="question-text">${this.currentQuestion.questionText}</div>
+                                <div class="answer-section">
+                                    <div class="answer-label">Current Answer:</div>
+                                    <div class="answer-text">
+                                        ${this.currentQuestion.currentAnswer || 'No answer yet...'}
+                                    </div>
+                                    <div class="completeness-bar">
+                                        <div class="completeness-fill" 
+                                             style="width: ${(this.currentQuestion.completeness_score || 0) * 100}%"></div>
+                                    </div>
+                                    <div class="completeness-label">
+                                        ${Math.round((this.currentQuestion.completeness_score || 0) * 100)}% complete
+                                    </div>
+                                </div>
+                            </div>
+                        ` : html`
+                            <div class="no-current-question">No active question detected</div>
+                        `}
+                    </div>
+                </div>
+
+                <!-- Next Question to Ask Section -->
+                <div class="section next-question">
+                    <h3 class="section-title">‚è≠Ô∏è Next Question to Ask</h3>
+                    <div class="next-question-content">
+                        ${this.nextQuestion ? html`
+                            <div class="next-question-display">
+                                <div class="next-question-text">${this.nextQuestion.questionText}</div>
+                                ${this.nextQuestion.reason !== 'next in sequence' ? html`
+                                    <div class="next-question-reason">Reason: ${this.nextQuestion.reason}</div>
+                                ` : ''}
+                            </div>
+                        ` : html`
+                            <div class="no-next-question">All questions addressed</div>
+                        `}
+                    </div>
+                </div>
+
+                <!-- Pending Questions Section (Collapsible) -->
+                <div class="section collapsible-section">
+                    <h3 class="section-title collapsible" 
+                        @click="${() => this.showPendingQuestions = !this.showPendingQuestions}">
+                        <span class="collapse-icon ${this.showPendingQuestions ? 'expanded' : ''}">‚ñ∂</span>
+                        üìã Pending Questions (${pendingQuestions.length})
+                    </h3>
+                    <div class="collapsible-content ${this.showPendingQuestions ? 'expanded' : ''}">
+                        ${pendingQuestions.map(([id, question]) => html`
+                            <div class="question-item">
+                                <div class="question-text">${question.text}</div>
+                                <div class="question-meta">
+                                    <span class="question-category">${question.category}</span>
+                                    <span class="question-priority ${question.priority}">${question.priority}</span>
+                                </div>
+                            </div>
+                        `)}
+                        ${pendingQuestions.length === 0 ? html`
+                            <div class="empty-state">No pending questions</div>
+                        ` : ''}
+                    </div>
+                </div>
+
+                <!-- Questions Already Asked Section (Collapsible) -->
+                <div class="section collapsible-section">
+                    <h3 class="section-title collapsible" 
+                        @click="${() => this.showAskedQuestions = !this.showAskedQuestions}">
+                        <span class="collapse-icon ${this.showAskedQuestions ? 'expanded' : ''}">‚ñ∂</span>
+                        ‚úÖ Questions Already Asked (${askedQuestions.length})
+                    </h3>
+                    <div class="collapsible-content ${this.showAskedQuestions ? 'expanded' : ''}">
+                        ${askedQuestions.map(([id, question]) => html`
+                            <div class="question-item">
+                                <div class="question-status-indicator ${question.status}"></div>
+                                <div class="question-content">
+                                    <div class="question-text">${question.text}</div>
+                                    <div class="question-meta">
+                                        <span class="question-category">${question.category}</span>
+                                        <span class="question-priority ${question.priority}">${question.priority}</span>
+                                        <span class="status-badge ${question.status}">${question.status}</span>
+                                        ${question.follow_up_needed ? html`
+                                            <span class="question-priority high">needs follow-up</span>
+                                        ` : ''}
+                                    </div>
+                                </div>
+                            </div>
+                        `)}
+                        ${askedQuestions.length === 0 ? html`
+                            <div class="empty-state">No questions asked yet</div>
+                        ` : ''}
+                    </div>
+                </div>
+
+                <!-- Session Controls -->
+                <div class="session-controls">
+                    <div class="session-stats">
+                        <span class="stat">${this.sessionStatus.questionsCompleted}/${this.sessionStatus.totalQuestions} completed</span>
+                        <span class="stat">${this.sessionStatus.completionPercentage}% progress</span>
+                    </div>
+                    <button class="btn btn-danger" @click="${this.endResearchSession}">
+                        End Research Session
+                    </button>
+                </div>
+            </div>
+        `;
+    }
+
+    renderAnalysisDashboard() {
+        return html`
+            <div class="analysis-dashboard">
+                <h3>Session Analysis</h3>
+                <p>Research session completed. Analysis features coming soon...</p>
+                <button class="btn btn-primary" @click="${() => this.mode = 'setup'}">
+                    Start New Session
+                </button>
+            </div>
+        `;
+    }
+
+
+
+    _handleStudySubmit(e) {
+        e.preventDefault();
+        const formData = new FormData(e.target);
+        const studyData = Object.fromEntries(formData.entries());
+        console.log('[ResearchView] Creating study with data:', studyData);
+        this.createStudy(studyData);
+    }
+
+    _handleQuestionSubmit(e) {
+        e.preventDefault();
+        const formData = new FormData(e.target);
+        const questionData = Object.fromEntries(formData.entries());
+        questionData.is_required = formData.has('is_required');
+        questionData.order_index = this.questions.length;
+        this.addQuestion(questionData);
+    }
+
+    async _deleteQuestion(questionId) {
+        if (confirm('Are you sure you want to delete this question?')) {
+            try {
+                await window.api.research.deleteQuestion(questionId);
+                await this.loadQuestions();
+            } catch (error) {
+                console.error('Failed to delete question:', error);
+            }
+        }
+    }
+
+    async _startSession() {
+        const participantId = `participant_${Date.now()}`;
+        console.log('[ResearchView] Starting session with participant ID:', participantId);
+        await this.startResearchSession({ participant_id: participantId });
+    }
+} 
\ No newline at end of file
diff --git a/src/window/windowManager.js b/src/window/windowManager.js
index 6c3de76..5f609c7 100644
--- a/src/window/windowManager.js
+++ b/src/window/windowManager.js
@@ -28,7 +28,7 @@ if (shouldUseLiquidGlass) {
 }
 /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[ GLASS BYPASS ]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
 
-let isContentProtectionOn = true;
+let isContentProtectionOn = false;
 let lastVisibleWindows = new Set(['header']);
 
 let currentHeaderState = 'apikey';
@@ -108,6 +108,36 @@ function setupWindowController(windowPool, layoutManager, movementManager) {
     internalBridge.on('window:requestToggleAllWindowsVisibility', ({ targetVisibility }) => {
         changeAllWindowsVisibility(windowPool, targetVisibility);
     });
+    internalBridge.on('window:requestNavigation', ({ view }) => {
+        console.log('[WindowManager] Navigation request received:', view);
+        const listenWin = windowPool.get('listen');
+        if (listenWin && !listenWin.isDestroyed()) {
+            const currentUrl = listenWin.webContents.getURL();
+            console.log('[WindowManager] Current URL:', currentUrl);
+            const url = new URL(currentUrl);
+            
+            let targetView = view;
+            
+            // Handle toggle logic for research view
+            if (view === 'toggle-research') {
+                const currentView = url.searchParams.get('view') || 'listen';
+                console.log('[WindowManager] Current view:', currentView, '-> Target view:', currentView === 'research' ? 'listen' : 'research');
+                targetView = currentView === 'research' ? 'listen' : 'research';
+            }
+            
+            url.searchParams.set('view', targetView);
+            const newUrl = url.toString();
+            console.log('[WindowManager] Loading new URL:', newUrl);
+            listenWin.loadURL(newUrl);
+            
+            // Make sure the window is visible
+            if (!listenWin.isVisible()) {
+                listenWin.show();
+            }
+        } else {
+            console.log('[WindowManager] Listen window not found or destroyed');
+        }
+    });
     internalBridge.on('window:moveToDisplay', ({ displayId }) => {
         // movementManager.moveToDisplay(displayId);
         const header = windowPool.get('header');
-- 
2.39.5 (Apple Git-154)

